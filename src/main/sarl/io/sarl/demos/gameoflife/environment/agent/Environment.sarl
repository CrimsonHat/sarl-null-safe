/**
 *
 */
package io.sarl.demos.gameoflife.environment.^agent

import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.demos.gameoflife.environment.^agent.events.AgentReadyForGame
import io.sarl.demos.gameoflife.environment.^agent.events.CellAgentUpdated
import io.sarl.demos.gameoflife.environment.^agent.events.GameIsDead
import io.sarl.demos.gameoflife.environment.^agent.events.PlayEvent
import io.sarl.demos.gameoflife.environment.^agent.events.RegisterEnvironmentListener
import io.sarl.demos.gameoflife.environment.^agent.events.RunBeginingOfStep
import io.sarl.demos.gameoflife.environment.^agent.events.RunEndOfStep
import io.sarl.lang.core.Address
import io.sarl.util.Scopes
import java.util.Collections
import java.util.concurrent.locks.ReentrantLock
import io.sarl.demos.gameoflife.environment.^agent.events.StopEvent
import io.sarl.demos.gameoflife.environment.^agent.events.PauseEvent

/**
 * @author Jérôme BOULMIER
 * @author Maxime PINARD
 */
agent Environment {
	uses DefaultContextInteractions, Lifecycle, GridManager, Logging;

	val listeners = <EnvironmentListener>newArrayList
	val actions = Collections.synchronizedList(<Action>newArrayList)
	var guiAlive = true; // FIXME: Replace this with the controller
	var paused = true;
	var numberOfAgent : int
	var agentCounter : int
	var lock = new ReentrantLock

	on Initialize {		
		var width = occurrence.parameters.get(0) as Integer
		var height = occurrence.parameters.get(1) as Integer
		listeners.add(occurrence.parameters.get(2) as EnvironmentListener)
		
		numberOfAgent = width * height

		setSkill(new DefaultGridManagerSkill(width, height), GridManager);

		emit(new AgentReadyForGame)
	}

	on CellAgentUpdated {
		info("RECEIVE: " + occurrence.position + ";" + occurrence.type)
		var tmp : int
		
		lock.lock
		try {
			if (occurrence.type != null) {
				actions.add(new Action(occurrence.source.UUID, occurrence.position, occurrence.type))
			}
			agentCounter++
			tmp = agentCounter
		} finally {
			lock.unlock
		}

		if (tmp == numberOfAgent) {
			emit(new RunEndOfStep)
		}
	}

	on PlayEvent {
		info("Starting the game.")

		lock.lock
		try {
			paused = false
		} finally {
			lock.unlock
		}
		
		emit(new RunBeginingOfStep, Scopes::addresses(defaultAddress))
	}
	
	on PauseEvent {
		lock.lock
		try {
			paused = true
		} finally {
			lock.unlock
		}
	}
	
	on StopEvent {
		lock.lock
		try {
			guiAlive = false
		} finally {
			lock.unlock
		}
	}

	on RunBeginingOfStep {
		info("Begin")
		lock.lock
		try {
			this.actions.clear
			agentCounter = 0
		} finally {
			lock.unlock
		}

		// Send perceptions
		for (p : getPerceptions) {
			val adr = new Address(defaultSpace.spaceID, p.key)
			emit(new Perception(p.value, isAlive(p.key), getPosition(p.key)), Scopes::addresses(adr))
		}
	}

	on RunEndOfStep {
		info("End")

		if (actions.size == 0) {
			emit(new GameIsDead)
			killMe
		} else {
			applyActions(actions)
			fireUpdate
	
			// Go to the next step
			if (guiAlive && !paused) {
				Thread.sleep(1000)
				emit(new RunBeginingOfStep, Scopes.addresses(defaultAddress))
			} else if (!paused) {
				info("Ending the game.")
				emit(new GameIsDead)
				killMe
			} else {
				info("Pausing the game.")
				Thread.yield
			}
	
			info("EndEnd")
		}
	}

	def fireUpdate {
		for (listener : listeners) {
			listener.handleGridUpdate(getGrid());
		}
	}

	on RegisterEnvironmentListener {
		listeners.add(occurrence.environmentListener);
	}
}

