/* 
 * $Id$
 * 
 * SARL is an general-purpose agent programming language.
 * More details on http://www.sarl.io
 * 
 * Copyright (C) 2014-2020 the original authors or authors.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.sarl.sre.skills.internal

import io.sarl.core.Logging
import io.sarl.lang.core.Agent
import io.sarl.lang.core.Event
import io.sarl.lang.core.Skill
import io.sarl.sre.capacities.InformedEventListener
import io.sarl.sre.capacities.InternalEventBusCapacity
import java.lang.ref.WeakReference
import java.util.UUID
import java.util.concurrent.ConcurrentLinkedDeque
import javax.inject.Inject

import static io.sarl.sre.services.lifecycle.AgentLife.*

/** 
 * SRE implementation of an internal skill that provides an event dispatcher to notify the different components/behaviors of an
 * agent.
 * 
 * @author $Author: srodriguez$
 * @author $Author: ngaud$
 * @author $Author: sgalland$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 */
@SuppressWarnings("potential_field_synchronization_problem")
skill InternalEventBusSkill extends Skill implements InternalEventBusCapacity {

	uses Logging

	val eventBus : EventBus

	var eventListener : InformedEventListener

	var isEventBufferEnabled = false

	var eventBuffer : ConcurrentLinkedDeque<Event> = null

	@Inject
	new (bus : EventBus) {
		super()
		this.eventBus = bus
	}

	override getEventBus : EventBus {
		this.eventBus
	}

	override getEventBus(type : Class<T>) : T with T extends EventBus {
		type.cast(this.eventBus)
	}

	protected override install {
		// Register the agent as a direct event listener.
		var bus = this.eventBus
		if (bus !== null) {
			bus.register(this.owner, null, null)
		}
	}

	protected override uninstall(stage : UninstallationStage) {
		if (stage == UninstallationStage::POST_DESTROY_EVENT) {
			var bus = this.eventBus
			if (bus !== null) {
				bus.unregisterAll(null)
			}
			this.eventListener = null
			this.eventBuffer = null;
		}
	}

	final def getAssociatedEventBusListener : InformedEventListener {
		var lst : InformedEventListener = this.eventListener

		if (lst === null) {
			lst = new ExternalEventBusAccessor(owner.ID, this)
			this.eventListener = lst
		}
		return lst
	}

	def registerEventBusListener(listener : Object, filter : (Event)=>boolean, callback : (Object)=>void) {
		this.eventBus.register(listener, filter, callback);
	}

	def unregisterEventBusListener(listener : Object, callback : (Object)=>void = null) {
		this.eventBus.unregister(listener, callback)
	}

	def unregisterEventBusListener(listenerType : Class<?>, callback : (Object)=>void = null) {
		this.eventBus.unregister(listenerType, callback)
	}

	/** Change the event buffering flag.
	 * 
	 * @param buffering the value of the flag.
	 * @return the value of the flag before its change.
	 */
	def setEventBuffering(buffering : boolean) : boolean {
		val old = this.isEventBufferEnabled
		this.isEventBufferEnabled = buffering
		return old
	}

	/** Replies if the events are buffering.
	 * 
	 * @return {@code true} if the events are buffered.
	 */
	def isEventBuffering() : boolean {
		return this.isEventBufferEnabled
	}

	/** Replies the buffered events.
	 * 
	 * @return an unmodifiable iterable of the buffered elements.
	 */
	def getBufferedEvents : ConcurrentLinkedDeque<Event> {
		if (this.eventBuffer === null) {
			return new ConcurrentLinkedDeque<Event>();
		}
		return new ConcurrentLinkedDeque(this.eventBuffer)
	}

	def fireEventAndWait(^event : Event, gatherEvents : boolean, thrownExceptions : boolean,
		listener : Object) : ConcurrentLinkedDeque<Event> {
		if (getLife(owner).state.blockingEventHandling) {
			if (gatherEvents) {
				var wasEnabled : boolean = this.isEventBufferEnabled
				this.isEventBufferEnabled = true

				try {
					this.eventBus.immediateDispatchTo(listener, ^event, thrownExceptions, getLogger)
				} finally {
					this.isEventBufferEnabled = wasEnabled
				}

				var cache = this.eventBuffer
				this.eventBuffer = null
				return cache

			}
			this.eventBus.immediateDispatchTo(listener, ^event, thrownExceptions, getLogger)
		}
		return new ConcurrentLinkedDeque<Event>
	}

	def fireEventAndWait(^event : Event, gatherEvents : boolean, thrownExceptions : boolean) : Iterable<Event> {
		if (getLife(owner).state.blockingEventHandling) {
			if (gatherEvents) {
				var wasEnabled : boolean = this.isEventBufferEnabled
				this.isEventBufferEnabled = true

				try {
					this.eventBus.immediateDispatch(^event, thrownExceptions, getLogger)
				} finally {
					this.isEventBufferEnabled = wasEnabled
				}

				var cache = this.eventBuffer
				this.eventBuffer = null
				return cache

			}
			this.eventBus.immediateDispatch(^event, thrownExceptions, getLogger)
		}
		return emptyList
	}

	def fireEvent(^event : Event) {
		if (getLife(owner).state.asynchronousEventHandling) {
			var mustBuf : boolean = this.isEventBufferEnabled

			if (mustBuf) {

				if (this.eventBuffer === null) {
					this.eventBuffer = new ConcurrentLinkedDeque
				}
				this.eventBuffer += ^event

			} else {
				this.eventBus.asyncDispatch(^event, getLogger)
			}
		}
	}

	def getRegisteredEventBusListeners(type : Class<T>) : ConcurrentLinkedDeque<T> with T {
		this.eventBus.getRegisteredEventListeners(type)
	}

	/** 
	 * The class in charge of dispatching every single events coming from the outside of this agent (i.e. from a space) or from an
	 * agent's behavior.
	 * 
	 * @author $Author: sgalland$
	 * @version $FullVersion$
	 * @mavengroupid $GroupId$
	 * @mavenartifactid $ArtifactId$
	 * 
	 */
	private static class ExternalEventBusAccessor implements InformedEventListener {

		val owner : WeakReference<InternalEventBusSkill>

		val id : UUID

		new (id : UUID, owner : InternalEventBusSkill) {
			this.id = id
			this.owner = new WeakReference(owner)
		}

		private def getOwnerSkill : InternalEventBusSkill {
			this.owner?.get
		}

		override receiveEvent(^event : Event) {
			this.ownerSkill?.fireEvent(^event)
		}

		override getID : UUID {
			this.id
		}

		override getOwnerInstance : Agent {
			this.ownerSkill?.owner
		}
	}

}
