/* 
 * $Id$
 * 
 * SARL is an general-purpose agent programming language.
 * More details on http://www.sarl.io
 * 
 * Copyright (C) 2014-2021 the original authors or authors.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.sarl.sre.services.lifecycle

import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.core.OpenEventSpace
import io.sarl.core.OpenEventSpaceSpecification
import io.sarl.lang.annotation.PrivateAPI
import io.sarl.lang.core.Address
import io.sarl.lang.core.Agent
import io.sarl.lang.core.AtomicSkillReference
import io.sarl.lang.core.EventListener
import io.sarl.lang.core.SREutils
import io.sarl.lang.core.Skill
import io.sarl.lang.core.SpaceID
import io.sarl.sre.capacities.InternalEventBusCapacity
import io.sarl.sre.services.context.Context
import java.util.List
import java.util.Map
import java.util.UUID
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.ConcurrentLinkedDeque
import java.util.concurrent.locks.ReadWriteLock
import java.util.logging.Level
import java.util.logging.Logger
import javax.inject.Provider

import static extension io.sarl.lang.core.SREutils.*
import java.util.concurrent.locks.ReentrantReadWriteLock

/** 
 * Describes any information that is required by the SRE for supporting the agent's life. 
 * 
 * @author $Author: sgalland$
 * @author $Author: ngaud$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 * @since 0.6.0
 */
@SuppressWarnings("use_reserved_sarl_annotation")
@PrivateAPI(isCallerOnly = true)
final class AgentLife {

	val lock : ReadWriteLock

	var stateObject = AgentState::UNSTARTED

	var agentInstance : Agent

	var innerContextInstance : Context

	var innerSpaceAddress : Address

	var externalContextInstances : Map<UUID, ContextReference>

	var defaultContextInstance : ContextReference

	var loggingCapacity : AtomicSkillReference

	var eventBusCapacity : AtomicSkillReference

	/** Replies the data structure that is storing the living data of the agent for the SRE.
	 * If this data structure does not exists, it is automatically created.
	 * 
	 * @param agent the instance of the agent for which the life description should be retrieved
	 * @param lockProvider the provider of locks
	 * @see #getLifeOrNull
	 */
	static def getLife(^agent : Agent, lockProvider : Provider<ReadWriteLock> = null) : AgentLife {
		// Do not need to synchronize this code because the creation of the agent life
		// object is done when spawning the agent, that is synchronously executed.
		var life = ^agent.getSreSpecificData(typeof(AgentLife))
		if (life === null) {
			if (lockProvider === null) {
				val lp : Provider<ReadWriteLock> = [ new ReentrantReadWriteLock ]
				life = new AgentLife(lp)
			} else {
				life = new AgentLife(lockProvider)
			}
			life.^agent = ^agent
			^agent.sreSpecificData = life
		}
		return life
	}

	/** Replies the data structure that is storing the living data of the agent for the SRE.
	 * If this data structure does not exists, it is NOT created.
	 * 
	 * @param agent the instance of the agent for which the life description should be retrieved
	 * @since 0.10
	 * @see #getLife
	 */
	@Pure
	static def getLifeOrNull(^agent : Agent) : AgentLife {
		// Do not need to synchronize this code because the creation of the agent life
		// object is done when spawning the agent, that is synchronously executed.
		return ^agent.getSreSpecificData(typeof(AgentLife))
	}

	/** Constructor.
	 *
	 * @param lockProvider the provider of locks
	 */
	new (lockProvider : Provider<ReadWriteLock>) {
		this.lock = lockProvider.get
	}

	override toString : String {
		this.^agent?.ID + "[" + getState.name + "]"
	}

	/** Replies the agent's logger.
	 * 
	 * @return the logger.
	 */
	final def getAgentLogger : Logging {
		// This implementation is lock-free because it is assumed that the skill definition will not change a lot.
		// The code is inspired from the similar code that is generated by the SARL compiler.
		var capRef = this.loggingCapacity
		if (capRef === null ||
			capRef.get() === null) {
			capRef = SREutils::getInternalSkillReference(this.^agent, typeof(Logging));
			this.loggingCapacity = capRef
		}
		return SREutils::castInternalSkillReference(this.^agent, capRef, typeof(Logging))
	}

	/** Replies the agent's event bus.
	 * 
	 * @return the event bus.
	 */
	final def getEventBus : InternalEventBusCapacity {
		// This implementation is lock-free because it is assumed that the skill definition will not change a lot.
		// The code is inspired from the similar code that is generated by the SARL compiler.
		var capRef = this.eventBusCapacity
		if (capRef === null || capRef.get() === null) {
			capRef = SREutils::getInternalSkillReference(this.^agent, typeof(InternalEventBusCapacity));
			this.eventBusCapacity = capRef
		}
		return SREutils::castInternalSkillReference(this.^agent, capRef, typeof(InternalEventBusCapacity))
	}

	/** Start the agent's life.
	 * 
	 * <p>This function is invoked for executing the born stage of the agent.
	 * 
	 * <p>If an exception is thrown into the initialization code of the agent, the exception is forwarded.
	 * 
	 * @param skillUninstaller the skill uninstaller.
	 * @param logger the logger to use for reporting initialization errors when the agent's logger is unavailable
	 * @param startError the exception that avoid to start the agent.
	 * @param spawningAgent the identifier of the agent which has spawn this starting agent. This agent could be outside the spawningContext.
	 * @param spawningContext the context in which the agent is spawned.
	 * @param initializationParameters the parameters to give to the agent for its start-up.
	 * @return {@code true} is successful, i.e. the {@code AgentSpawned} could be fired.
	 */
	def start(skillUninstaller : SkillUninstaller, logger : Logger, spawningAgent : UUID,
		spawningContext : Context, initializationParameters : Object*) : boolean {
		val rlock0 = this.lock.readLock
		var st : AgentState
		rlock0.lock
		try {
			st = this.stateObject
		} finally {
			rlock0.unlock
		}
		if (st === AgentState::UNSTARTED) {
			try {
				val wlock0 = this.lock.writeLock
				wlock0.lock
				try {
					st = this.stateObject
					if (st !== AgentState::UNSTARTED) {
						return false
					}
					this.stateObject = AgentState::INITIALIZING
				} finally {
					wlock0.unlock
				}

				// Get the event bus
				val eb = getEventBus
				assert eb !== null
				
				// Attach to the default context
				spawningContext.attachAgentToDefaultContext

				// Notify the agent about its creation.
				// Assume event handlers were run after returning from the fireEventAndWait function.
				var initEvent = new Initialize(spawningAgent, initializationParameters)
				initEvent.source = addressInInnerDefaultSpace
				// Any exception into the inits are thrown outside the call below.
				var delayedEvents = eb.fireEventAndWaitWithEventGathering(initEvent, true) [
					spawningContext.defaultSpace.registerStrongParticipant(eb.associatedEventBusListener)
				]

				// State may have changed
				val rlock1 = this.lock.readLock
				rlock1.lock
				try {
					st = this.stateObject
				} finally {
					rlock1.unlock
				}
				if (st === AgentState::INITIALIZING) {
					val wlock1 = this.lock.writeLock
					wlock1.lock
					try {
						this.stateObject = AgentState::ALIVE
					} finally {
						wlock1.unlock
					}
					if (delayedEvents !== null) {
						for (delayedEvent : delayedEvents) {
							eb.fireEvent(delayedEvent)
						}
					}
					return true
				} else {
					stop(skillUninstaller, logger, true)
					return false
				}
			} catch (e : Throwable) {
				try {
					this.agentLogger.error(e.localizedMessage, e)
				} catch (iex : Throwable) {
					logger.log(Level::SEVERE, e) [e.localizedMessage]
				}
				stop(skillUninstaller, logger, true)
				throw e
			}
		}
		return false
	}

	/** Set up the agent in order to be attached properly to its default context.
	 * 
	 * @param spawningContext the context in which the agent is spawn.
	 * @param eventBus the event bus of the agent.
	 * @since 0.12
	 */
	protected def attachAgentToDefaultContext(spawningContext : Context) : void {
		// Register the agent on its parent default space.
		var defaultSpace = spawningContext.defaultSpace
		var addressWithinDefaultSpace = new Address(defaultSpace.spaceID, ^agent.ID)
		setDefaultContext(spawningContext, addressWithinDefaultSpace)
	}

	/** Detach the agent from the platform.
	 * 
	 * <p>This function removes the agent from the default space of its default context.
	 * 
	 * @param listener the listener on space events that must be unregistered.
	 * @param enclosingContexts is the list of context for which we should be sure that the agent is out.
	 */
	protected def detachAgentFromPlatform(listener : EventListener, enclosingContexts : ConcurrentLinkedDeque<ContextReference>) : void {
		val rlock = this.lock.readLock
		var contextReference : ContextReference
		rlock.lock
		try {
			contextReference = this.defaultContextInstance
		} finally {
			rlock.unlock
		}

		// Unregister the agent on its parent default space.
		var theDefaultSpace : OpenEventSpace = null
		if (contextReference !== null) {
			var ds = contextReference.defaultSpace
			if (ds !== null) {
				theDefaultSpace = ds
			}
		}
		
		// Ensure that the agent is outside all the external contexts
		for (ctxRef : enclosingContexts) {
			val spc = ctxRef.defaultSpace
			if (spc !== null && theDefaultSpace !== spc) {
				spc.unregister(listener)
			}
		}

		if (theDefaultSpace !== null) {
			theDefaultSpace.unregister(listener)
		}
	}

	/** Stop the agent's life.
	 * 
	 * <p>This function is invoked for executing the killing stage of the agent.
	 * 
	 * @param skillUninstaller the skill uninstaller.
	 * @param logger the logger to use for reporting initialization errors when the agent's logger is unavailable
	 * @param fireDestroy indicates if the {@code Destroy} event should be fired.
	 * @return the contexts from which the agent was removed.
	 */
	def stop(skillUninstaller : SkillUninstaller, logger : Logger,
		fireDestroy : boolean = true) : ConcurrentLinkedDeque<ContextReference> {

		this.state = AgentState::DYING

		val dyingAgent = ^agent
		assert dyingAgent !== null

		try {
			// Copy the external event listener in order to unregistered it later.
			var listener = this.eventBus.associatedEventBusListener

			// Pre-stage for uninstalling the skills (BIC and user defined)
			var skills : List<? extends Skill>
			try {
				skills = skillUninstaller.uninstallSkillsBeforeDestroy(dyingAgent)
			} catch (e : Throwable) {
				logger.log(Level::SEVERE, e) [e.localizedMessage]
				skills = newArrayList
			}
			
			assert skills !== null

			if (fireDestroy) {
				try {
					// Notify the agent about its destruction.
					var ^event = new Destroy
					^event.source = addressInInnerDefaultSpace
					this.eventBus.fireEventAndWait(^event, false)
				} catch (e : Throwable) {
					try {
						this.agentLogger.error(e.localizedMessage, e)
					} catch (ex : Throwable) {
						logger.log(Level::SEVERE, e) [e.localizedMessage]
					}
				}
			}

			// Copy the contexts in which the agents is registered in order to reply them.
			var enclosingContextsCopy = new ConcurrentLinkedDeque<ContextReference>
			var contexts = getEnclosingContexts

			enclosingContextsCopy += contexts

			// Final stage for uninstalling the skills (BIC and user defined)
			try {
				skillUninstaller.uninstallSkillsAfterDestroy(dyingAgent, skills)
			} catch (e : Throwable) {
				logger.log(Level::SEVERE, e) [e.localizedMessage]
			}

			// Detach the agent form the platform
			detachAgentFromPlatform(listener, enclosingContextsCopy)

			// Force unregistration to the enclosing spaces
			return enclosingContextsCopy
		} catch (e : Throwable) {
			logger.log(Level::SEVERE, e) [e.localizedMessage]
			return new ConcurrentLinkedDeque
		} finally {
			this.state = AgentState::DEAD
			// Clear the references
			dyingAgent.setSreSpecificData(null)
			val wlock = this.lock.writeLock
			wlock.lock
			try {
				this.externalContextInstances = null
				this.defaultContextInstance = null
			} finally {
				wlock.unlock
			}
			this.agentInstance = null

		}
	}

	/** Replies the agent associated to this life.
	 */
	def getAgent : Agent {
		return this.agentInstance
	}

	/** Change the agent associated to this life.
	 */
	def setAgent(^agent : Agent) {
		this.agentInstance = ^agent
	}

	/** Replies the agent state.
	 */
	def getState : AgentState {
		val lock = this.lock.readLock
		lock.lock
		try {
			return this.stateObject
		} finally {
			lock.unlock
		}
	}

	/** Change the agent state.
	 */
	def setState(state : AgentState) {
		assert state !== null
		val lock = this.lock.writeLock
		lock.lock
		try {
			this.stateObject = state
		} finally {
			lock.unlock
		}
	}

	/** Set the inner context reference.
	 * 
	 * @param innerContext the instance of inner context, or {@code null}
	 * @return the previous context, or {@code null}.
	 */
	def setInnerContext(innerContext : Context) : Context {
		val lock = this.lock.writeLock
		lock.lock
		try {
			var old = this.innerContextInstance
			this.innerContextInstance = innerContext
			return old
		} finally {
			lock.unlock
		}
	}

	/** Replies the inner context reference.
	 * 
	 * @param creator is invoked to create the inner context thread-safely. If is it {@code null},
	 *     the context will not be created on-the-fly if it is not already known.
	 * @return the instance of inner context, or {@code null}
	 */
	def getInnerContext(creator : (AgentLife)=>Context) : Context {
		val rlock = this.lock.readLock
		var ctx : Context 
		rlock.lock
		try {
			ctx = this.innerContextInstance
		} finally {
			rlock.unlock
		}
		if (ctx === null && creator !== null) {
			val newInstance = creator.apply(this)
			val wlock = this.lock.writeLock
			wlock.lock
			try {
				ctx = this.innerContextInstance
				if (ctx === null) {
					this.innerContextInstance = newInstance
					ctx = this.innerContextInstance
				}
			} finally {
				wlock.unlock
			}
		}
		return ctx
	}

	/** Replies the address of the agent into the default space of its inner context.
	 * 
	 * @return the address, never {@code null}.
	 */
	def getAddressInInnerDefaultSpace : Address {
		val rlock = this.lock.readLock
		var adr : Address
		rlock.lock
		try {
			adr = this.innerSpaceAddress
		} finally {
			rlock.unlock
		}
		if (adr === null) {
			var aid = this.^agent.ID
			var spaceid = new SpaceID(aid, UUID::randomUUID, typeof(OpenEventSpaceSpecification))
			adr = new Address(spaceid, aid);
			val wlock = this.lock.writeLock
			wlock.lock
			try {
				if (this.innerSpaceAddress === null) {
					this.innerSpaceAddress = adr
				}
			} finally {
				wlock.unlock
			}
		}
		return adr
	}

	/** Add a context in which the agent is located.
	 * 
	 * @param context the context in which the agent is now located.
	 * @param address the address of the agent in the default space of the given context.
	 * @return the created reference, or {@code null} if the reference cannot be added (because the given context is already the default context).
	 */
	def addExternalContext(context : Context, address : Address) : ContextReference {
		assert context !== null
		assert address !== null
		var validation = false
		val rlock = this.lock.readLock
		rlock.lock
		try {
			validation = (this.defaultContextInstance === null || context.ID != this.defaultContextInstance.context.ID)
		} finally {
			rlock.unlock
		}
		if (validation) {
			val wlock = this.lock.writeLock
			wlock.lock
			try {
				validation = (this.defaultContextInstance === null || context.ID != this.defaultContextInstance.context.ID)
				if (validation) {
					var ref = new ContextReference(this, context, address)
					ensureExternalContextInstances.put(context.ID, ref)
					return ref
				}
			} finally {
				wlock.unlock
			}
		}
		return null
	}

	/** Remove a context in which the agent is located.
	 */
	def removeExternalContext(context : Context) : ContextReference {
		assert context !== null
		var lck = this.lock.writeLock
		lck.lock
		try {
			if (this.externalContextInstances !== null) {
				var ctx = this.externalContextInstances.remove(context.ID)
				if (this.externalContextInstances !== null && this.externalContextInstances.empty) {
					this.externalContextInstances = null
				}
				return ctx
			}
			return null
		} finally {
			lck.unlock
		}
	}

	/** Remove a context in which the agent is located.
	 */
	def removeExternalContext(context : ContextReference) : ContextReference {
		assert context !== null
		var lck = this.lock.writeLock
		lck.lock
		try {
			if (this.externalContextInstances !== null) {
				var ctx = this.externalContextInstances.remove(context.context.ID)
				if (this.externalContextInstances.empty) {
					this.externalContextInstances = null
				}
				return ctx
			}
			return null
		} finally {
			lck.unlock
		}
	}

	/** Replies the external contexts in which the agent is located.
	 * The default context is not part of the replied collection.
	 * 
	 * @see {@link #getEnclosingContexts()}
	 */
	def getExternalContexts : ConcurrentLinkedDeque<ContextReference> {
		var result = new ConcurrentLinkedDeque
		val rlock = this.lock.readLock
		rlock.lock
		try {
			if (this.externalContextInstances !== null) {
				val dcId = this.defaultContextInstance?.context?.ID
				var foundDefaultContext = false
				for (entry : this.externalContextInstances.entrySet) {
					if (!foundDefaultContext && dcId == entry.key) {
						foundDefaultContext = true
					} else {
						result += entry.value
					}
				}
			}
		} finally {
			rlock.unlock
		}
		return result
	}

	/** Replies the number of external contexts in which the agent is located.
	 * The default context is not counted.
	 * 
	 * @return the number of external contexts.
	 */
	def getExternalContextCount : int {
		var lck = this.lock.writeLock
		lck.lock
		try {
			if (this.externalContextInstances === null) {
				return 0
			}
			return this.externalContextInstances.size
		} finally {
			lck.unlock
		}
	}

	/** Replies all the contexts in which the agent is located, including the default context and
	 * the external contexts.
	 * 
	 * @see {@link #getExternalContexts()}
	 */
	def getEnclosingContexts : ConcurrentLinkedDeque<ContextReference> {
		val rlock = this.lock.readLock
		rlock.lock
		try {
			if (this.defaultContextInstance !== null) {
				var result = new ConcurrentLinkedDeque
				if (this.externalContextInstances === null) {
					result.add(this.defaultContextInstance)
					return result
				}
				var foundDefaultContext = false
				val dcId = this.defaultContextInstance.context.ID
				for (entry : this.externalContextInstances.entrySet) {
					result += entry.value
					if (!foundDefaultContext && dcId == entry.key) {
						foundDefaultContext = true
					}				
				}
				if (!foundDefaultContext) {
					result += this.defaultContextInstance
				}
				return result
			} else if (this.externalContextInstances === null) {
				return new ConcurrentLinkedDeque
			} else {
				return new ConcurrentLinkedDeque(this.externalContextInstances.values)
			}
		} finally {
			rlock.unlock
		}
	}

	/** Replies the external context with the given identifier.
	 * 
	 * @param identifer the identifier of the context.
	 * @return the context, or {@code null} 
	 */
	def getExternalContext(identifier : UUID) : ContextReference {
		val rlock = this.lock.readLock
		rlock.lock
		try {
			if (this.externalContextInstances !== null) {
				return this.externalContextInstances.get(identifier)
			}
			return null
		} finally {
			rlock.unlock
		}
	}

	/** Change the default context of the agent.
	 * 
	 * @param context the next context, never {@code null}.
	 * @param address the address of the agent into the default space of the given context.
	 * @return the reference to the previous default context.
	 */
	def setDefaultContext(context : Context, address : Address) : ContextReference {
		assert context !== null
		assert address !== null
		val nc = new ContextReference(this, context, address)
		var oldDefaultSpace : ContextReference 
		val wlock = this.lock.writeLock
		wlock.lock
		try {
			oldDefaultSpace = this.defaultContextInstance
			this.defaultContextInstance = nc
		} finally {
			wlock.unlock
		}
		removeExternalContext(context)
		return oldDefaultSpace
	}

	private def ensureExternalContextInstances : Map<UUID, ContextReference> {
		if (this.externalContextInstances === null) {
			this.externalContextInstances = new ConcurrentHashMap<UUID, ContextReference>
		}
		return this.externalContextInstances
	}

	/** Replies the default context of the agent.
	 * 
	 * @return the default context, never {@code null}.
	 */
	def getDefaultContext : ContextReference {
		val lock = this.lock.readLock
		lock.lock
		try {
			return this.defaultContextInstance
		} finally {
			lock.unlock
		}
	}

}

/** 
 * Describes any information that is required by the SRE for supporting the agent's life. 
 * 
 * @author $Author: sgalland$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 * @since 0.6.0
 */
final class ContextReference implements Comparable<ContextReference>, Cloneable {

	val life : AgentLife

	val contextInstance : Context

	var defaultAddress : Address

	/** Constructor.
	 * 
	 * @param context the content to reference.
	 * @param address the address of the agent in the default space of the given context.
	 */
	new (life : AgentLife, context : Context, address : Address) {
		assert life !== null
		assert context !== null
		assert address !== null
		this.life = life
		this.contextInstance = context
		this.defaultAddress = address
	}

	override clone : ContextReference {
		new ContextReference(this.life, this.contextInstance, this.defaultAddress)
	}

	override toString : String {
		var context = this.contextInstance
		if(context === null) "[?]" else context.toString
	}

	override compareTo(o : ContextReference) : int {
		if(o === null) return Integer::MAX_VALUE
		return this.contextInstance.ID <=> o.contextInstance.ID
	}

	/** Replies the context.
	 */
	def getContext : Context {
		this.contextInstance
	}

	/** Replies the default space.
	 */
	def getDefaultSpace : OpenEventSpace {
		this.contextInstance.defaultSpace
	}

	/** Replies the address of the agent into the default space.
	 */
	def getAddressInDefaultSpace : Address {
		if (this.defaultAddress === null) {
			this.defaultAddress = this.contextInstance.defaultSpace.getAddress(this.life.^agent.ID)
		}
		assert(this.defaultAddress !== null)
		this.defaultAddress
	}

}
