/*
 * $Id$
 *
 * SARL is an general-purpose agent programming language.
 * More details on http://www.sarl.io
 *
 * Copyright (C) 2014-2020 the original authors or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.sarl.sre.tests.units.services.lifecycle

import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.OpenEventSpace
import io.sarl.core.OpenEventSpaceSpecification
import io.sarl.lang.core.Address
import io.sarl.lang.core.Agent
import io.sarl.lang.core.Event
import io.sarl.lang.core.SpaceID
import io.sarl.sarlspecification.SarlSpecificationChecker
import io.sarl.sre.boot.configs.subconfigs.LifecycleConfig
import io.sarl.sre.services.context.Context
import io.sarl.sre.services.context.ExternalContextMemberListener
import io.sarl.sre.services.executor.ExecutorService
import io.sarl.sre.services.lifecycle.AbstractLifecycleService
import io.sarl.sre.services.lifecycle.AgentCreatorProvider
import io.sarl.sre.services.lifecycle.AgentLife
import io.sarl.sre.services.lifecycle.AgentState
import io.sarl.sre.services.lifecycle.ContextReference
import io.sarl.sre.services.lifecycle.InvalidSarlSpecificationException
import io.sarl.sre.services.lifecycle.KernelAgentLifecycleListener
import io.sarl.sre.services.lifecycle.LifecycleServiceListener
import io.sarl.sre.services.lifecycle.SkillUninstaller
import io.sarl.sre.services.lifecycle.SpawnDisabledException
import io.sarl.sre.services.logging.LoggingService
import io.sarl.sre.test.framework.^extension.PropertyRestoreExtension
import io.sarl.sre.tests.units.services.lifecycle.mocks.InvalidMyAgent1
import io.sarl.sre.tests.units.services.lifecycle.mocks.InvalidMyAgent2
import io.sarl.sre.tests.units.services.lifecycle.mocks.MyAgent0
import io.sarl.sre.tests.units.services.lifecycle.mocks.MyEventBus
import io.sarl.tests.api.Nullable
import io.sarl.tests.api.extensions.ContextInitExtension
import io.sarl.tests.api.extensions.JavaVersionCheckExtension
import java.util.UUID
import java.util.concurrent.ConcurrentSkipListSet
import java.util.concurrent.CopyOnWriteArraySet
import java.util.concurrent.Future
import java.util.logging.Logger
import javax.inject.Provider
import org.eclipse.xtext.xbase.lib.Functions.Function0
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith
import org.mockito.ArgumentCaptor

import static io.sarl.sre.test.framework.^extension.ServiceManagementExtension.*
import static io.sarl.tests.api.tools.TestAssertions.*
import static org.junit.jupiter.api.Assertions.*
import static org.mockito.ArgumentMatchers.*
import static org.mockito.Mockito.*

import static extension io.sarl.sre.services.lifecycle.AgentLife.*
import static extension io.sarl.tests.api.tools.TestAssertions.assertException
import static extension io.sarl.tests.api.tools.TestMockito.mock
import static extension org.mockito.ArgumentMatchers.any
import static extension org.mockito.Mockito.spy
import static extension org.mockito.Mockito.verify

/**
 * @author $Author: sgalland$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 */
@ExtendWith(#[
	typeof(ContextInitExtension),
	typeof(JavaVersionCheckExtension),
	typeof(PropertyRestoreExtension)
])
abstract class AbstractLifecycleServiceTest<T extends AbstractLifecycleService> {

	@Nullable
	protected var contextId : UUID

	@Nullable
	protected var agentId : UUID
	
	@Nullable
	protected var ^agent : Agent

	@Nullable
	protected var agent2 : Agent

	@Nullable
	protected var outContext : Context

	@Nullable
	var executor : ExecutorService

	@Nullable
	var logger : LoggingService

	@Nullable
	protected var checker : SarlSpecificationChecker

	@Nullable
	var skillUninstaller : SkillUninstaller

	@Nullable
	var eventBus : MyEventBus

	@Nullable
	protected var service : T

	@Nullable
	var agentCreatorProvider : AgentCreatorProvider
	
	@BeforeEach
	def setUp : void {
		this.contextId = UUID::randomUUID
		this.outContext = typeof(Context).mock
		this.eventBus = new MyEventBus().spy
		when(this.outContext.ID).thenReturn(this.contextId)
		var ^space = typeof(OpenEventSpace).mock
		when(this.outContext.defaultSpace).thenReturn(^space)
		when(^space.spaceID).thenReturn(new SpaceID(this.contextId, UUID::randomUUID, typeof(OpenEventSpaceSpecification)))
		this.agentId = UUID::randomUUID()
		this.^agent = new MyAgent0(this.contextId, this.agentId).spy
		when(this.^agent.ID).thenReturn(this.agentId)
		this.agent2 = new MyAgent0(this.contextId, this.agentId, this.eventBus).spy
		when(this.^agent2.ID).thenReturn(this.agentId)
		this.checker = typeof(SarlSpecificationChecker).mock

		var agentProvider = typeof(Provider).mock
		when(agentProvider.get).thenReturn(this.^agent2)
		this.agentCreatorProvider = typeof(AgentCreatorProvider).mock
		when(this.agentCreatorProvider.getAgentCreator(typeof(Class).any,
			typeof(UUID).any, anyInt, typeof(Iterable).any, typeof(Function0).any)).thenReturn(agentProvider)

		this.executor = typeof(ExecutorService).mock
		// Execute the code synchronously only for testing purpose
		doAnswer([
			val r = it.getArgument(1) as Runnable
			r.run
			return typeof(Future).mock
		]).when(this.executor).executeAsap(typeof(Logger).any, typeof(Runnable).any)
		
		this.logger = typeof(LoggingService).mock
		when(this.logger.kernelLogger).thenReturn(typeof(Logger).mock)
		this.skillUninstaller = typeof(SkillUninstaller).mock
		when(this.skillUninstaller.uninstallSkillsBeforeDestroy(any)).thenReturn(new CopyOnWriteArraySet)

		this.service = newService(
			this.executor,
			this.logger,
			this.skillUninstaller,
			this.agentCreatorProvider,
			[typeof(ExternalContextMemberListener).mock],
			[typeof(LifecycleServiceListener).mock],
			[new LifecycleConfig]
		).spy
	}

	protected abstract def newService(executor : ExecutorService, logger : LoggingService,
		skillUninstaller : SkillUninstaller, agentCreatorProvider : AgentCreatorProvider,
		contextListenerProvider : Provider<ExternalContextMemberListener>,
		lifecycleListenerProvider : Provider<LifecycleServiceListener>,
		lifecycleConfig: Provider<LifecycleConfig>) : T

	protected def startService {
		startServiceManually(this.service)
	}
	
	private def createInnerContext(ids : UUID*) {
		var innerContext = typeof(Context).mock
		AgentLife::getLife(this.^agent).innerContext = innerContext
		var ^space = typeof(OpenEventSpace).mock
		when(innerContext.defaultSpace).thenReturn(^space)
		var set = new ConcurrentSkipListSet<UUID>
		set += this.agentId
		set += ids
		when(^space.participants).thenReturn(set)
	}

	private def createOuterContext(^agent : Agent) : Context {
		var contextId = UUID::randomUUID
		var context = typeof(Context).mock
		when(context.ID).thenReturn(contextId)
		var ^space = typeof(OpenEventSpace).mock
		when(context.defaultSpace).thenReturn(^space)
		when(^space.spaceID).thenReturn(new SpaceID(contextId, UUID::randomUUID, typeof(OpenEventSpaceSpecification)))
		var set = new ConcurrentSkipListSet<UUID>
		set += this.agentId
		set += #[^agent.ID]
		when(^space.participants).thenReturn(set)
		return context
	}

	@Test
	def isKillableAgent_noInnerContext {
		assertTrue(this.service.isKillableAgent(this.^agent.getLife, this.^agent.ID))
	}

	@Test
	def isKillableAgent_emptyInnerContext {
		createInnerContext
		assertTrue(this.service.isKillableAgent(this.^agent.getLife, this.^agent.ID))
	}

	@Test
	def isKillableAgent_oneChild {
		createInnerContext(UUID::randomUUID)
		assertFalse(this.service.isKillableAgent(this.^agent.getLife, this.^agent.ID))
	}

	@Test
	def isKillableAgent_twoChild {
		createInnerContext(UUID::randomUUID, UUID::randomUUID)
		assertFalse(this.service.isKillableAgent(this.^agent.getLife, this.^agent.ID))
	}

	@Test
	def spawnAgent_0_serviceNotStarted {
		typeof(SpawnDisabledException).assertException [
			this.service.spawnAgent(0, null, this.outContext, null, null, null)
		]
	}
	
	@Test
	def spawnAgent_0 {
		startService
		typeof(SpawnDisabledException).assertException [
			this.service.spawnAgent(0, null, this.outContext, null, null, null)
		]
	}

	@Test
	def spawnAgent_1_serviceNotStarted {
		typeof(SpawnDisabledException).assertException [
			this.service.spawnAgent(1, null, this.outContext, null, null, null)
		]
	}

	def assertNoException(ex : Throwable) : void {
		if (ex !== null) {
			throw new RuntimeException(ex)
		}
	}

	@Test
	def spawnAgent_1 {
		startService
		var newAgentId = UUID::randomUUID
		when(this.agent2.ID).thenReturn(newAgentId)
		var listener1 = typeof(LifecycleServiceListener).mock
		this.service.addLifecycleServiceListener(listener1)
		var listener2 = typeof(KernelAgentLifecycleListener).mock
		this.service.addKernelAgentLifecycleListener(listener2)
		
		when(this.checker.isValidSarlElement(any)).thenReturn(true)
		
		this.service.spawnAgent(1, this.agentId, this.outContext, newAgentId, typeof(MyAgent0), null, 1, "a")

		// Agent State
		assertSame(AgentState.ALIVE, AgentLife::getLife(this.agent2).state)
		
		// Agent Initialize
		var capEvent = ArgumentCaptor::forClass(typeof(Event))
		var capGatherEvents = ArgumentCaptor::forClass(typeof(boolean))
		var capThrownExceptions = ArgumentCaptor::forClass(typeof(boolean))
		this.eventBus.verify.fireEventAndWait(capEvent.capture, capGatherEvents.capture.booleanValue,
			capThrownExceptions.capture.booleanValue)
		assertTrue(capGatherEvents.value)
		assertTrue(capThrownExceptions.value)
		assertInstanceOf(typeof(Initialize), capEvent.value)
		var initEvent = capEvent.value as Initialize
		assertNotNull(initEvent.source)
		assertEquals(this.agentId, initEvent.spawner)
		assertContains(initEvent.parameters, 1, "a")

		// Agent spawned
		var capSpawningAgent = ArgumentCaptor::forClass(typeof(UUID))
		var capParentContext = ArgumentCaptor::forClass(typeof(Context))
		var capAgentType = ArgumentCaptor::forClass(typeof(Class))
		var capAgents = ArgumentCaptor::forClass(typeof(Agent))
		var capParams = ArgumentCaptor::forClass(typeof(Object[]))
		listener1.verify.agentSpawned(
				capSpawningAgent.capture,
				capParentContext.capture,
				capAgentType.capture,
				capAgents.capture,
				capParams.capture)
		assertEquals(this.agentId, capSpawningAgent.value)
		assertSame(this.outContext, capParentContext.value)
		assertSame(typeof(MyAgent0), capAgentType.value)
		assertContains(#[capParams.value], 1, "a")
		assertSame(this.agent2, capAgents.value)

		// Kernel event.
		verifyNoMoreInteractions(listener2)
	}

	@Test
	def spawnAgent_1_noSpec {
		startService
		var newAgentId = UUID::randomUUID
		typeof(InvalidSarlSpecificationException).assertException [
			this.service.spawnAgent(1, this.agentId, this.outContext, newAgentId, typeof(InvalidMyAgent1),
				null, 1, "a")
		]
	}

	@Test
	def spawnAgent_1_invalidSpec {
		startService
		var newAgentId = UUID::randomUUID
		typeof(InvalidSarlSpecificationException).assertException [
			this.service.spawnAgent(1, this.agentId, this.outContext, newAgentId, typeof(InvalidMyAgent2),
				null, 1, "a")
		]
	}

	@Test
	def killAgent_noInnerContext_serviceNotStarted {
		assertFalse(this.service.killAgent(this.^agent))
	}

	@Test
	def killAgent_noInnerContext_serviceStarted {
		var listener1 = typeof(LifecycleServiceListener).mock
		this.service.addLifecycleServiceListener(listener1)
		var listener2 = typeof(KernelAgentLifecycleListener).mock
		this.service.addKernelAgentLifecycleListener(listener2)

		startService
		var defaultContext = createOuterContext(this.agent2)
		AgentLife::getLife(this.agent2).setDefaultContext(defaultContext,
				new Address(defaultContext.defaultSpace.spaceID, this.^agent.ID))
		var outerContext = createOuterContext(this.agent2)
		AgentLife::getLife(this.agent2).addExternalContext(outerContext,
				new Address(outerContext.defaultSpace.spaceID, this.^agent.ID))
		AgentLife::getLife(this.agent2).state = AgentState::ALIVE

		assertTrue(this.service.killAgent(this.agent2))
		
		// Uninstall the skills
		var capAgent = ArgumentCaptor::forClass(typeof(Agent))
		this.skillUninstaller.verify.uninstallSkillsBeforeDestroy(capAgent.capture)
		assertSame(this.agent2, capAgent.value)
		
		capAgent = ArgumentCaptor::forClass(typeof(Agent))
		var capSkills = ArgumentCaptor::forClass(typeof(CopyOnWriteArraySet))
		this.skillUninstaller.verify.uninstallSkillsAfterDestroy(capAgent.capture, capSkills.capture)
		assertSame(this.agent2, capAgent.value)
		assertNotNull(capSkills.value)

		// Destroy event
		var capEvent = ArgumentCaptor::forClass(typeof(Event))
		var capGatherEvents = ArgumentCaptor::forClass(typeof(boolean))
		var capThrownExceptions = ArgumentCaptor::forClass(typeof(boolean))
		this.eventBus.verify.fireEventAndWait(capEvent.capture, capGatherEvents.capture.booleanValue,
			capThrownExceptions.capture.booleanValue)
		assertFalse(capGatherEvents.value)
		assertFalse(capThrownExceptions.value)
		assertInstanceOf(typeof(Destroy), capEvent.value)
		var destroyEvent = capEvent.value as Destroy
		assertNotNull(destroyEvent.source)
		
		// Agent destroy notification
		capAgent = ArgumentCaptor::forClass(typeof(Agent))
		var capContexts : ArgumentCaptor<Iterable<ContextReference>> = ArgumentCaptor::forClass(typeof(Iterable))
		listener1.verify.agentDestroyed(capAgent.capture, capContexts.capture)
		assertEquals(this.agent2, capAgent.value)
		assertContains(
			capContexts.value.map [it.getContext],
				defaultContext, outerContext)
		
		// Kernel destroy
		verifyNoMoreInteractions(listener2)
	}

	@Test
	def killAgent_emptyInnerContext_serviceNotStarted {
		createInnerContext
		assertTrue(this.service.isKillableAgent(this.^agent.getLife, this.^agent.ID))
	}

	@Test
	def killAgent_emptyInnerContext_serviceStarted {
		startService
		createInnerContext
		assertTrue(this.service.isKillableAgent(this.^agent.getLife, this.^agent.ID))
	}

	@Test
	def killAgent_oneChild {
		createInnerContext(UUID::randomUUID)
		assertFalse(this.service.isKillableAgent(this.^agent.getLife, this.^agent.ID))
	}

	@Test
	def killAgent_twoChild {
		createInnerContext(UUID::randomUUID, UUID::randomUUID)
		assertFalse(this.service.isKillableAgent(this.^agent.getLife, this.^agent.ID))
	}

}
