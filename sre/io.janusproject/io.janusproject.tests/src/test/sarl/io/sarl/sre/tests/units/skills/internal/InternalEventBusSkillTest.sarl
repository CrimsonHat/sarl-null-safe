/*
 * $Id$
 *
 * SARL is an general-purpose agent programming language.
 * More details on http://www.sarl.io
 *
 * Copyright (C) 2014-2021 the original authors or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.sarl.sre.tests.units.skills.internal

import io.sarl.lang.core.Agent
import io.sarl.lang.core.Event
import io.sarl.lang.core.EventListener
import io.sarl.sre.services.lifecycle.AgentState
import io.sarl.sre.skills.internal.EventBus
import io.sarl.sre.skills.internal.InternalEventBusSkill
import io.sarl.sre.test.framework.^extension.PropertyRestoreExtension
import io.sarl.sre.tests.units.skills.internal.mocks.MyAgent
import io.sarl.sre.tests.units.skills.internal.mocks.MyLoggingSkill
import io.sarl.tests.api.Nullable
import io.sarl.tests.api.extensions.ContextInitExtension
import io.sarl.tests.api.extensions.JavaVersionCheckExtension
import io.sarl.util.ConcurrentCollectionLinkedDeque
import java.util.UUID
import java.util.logging.Logger
import org.eclipse.xtext.xbase.lib.Functions.Function1
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.api.Tag
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith

import static extension io.sarl.tests.api.tools.TestAssertions.*
import static extension io.sarl.tests.api.tools.TestReflections.*
import static extension org.junit.jupiter.api.Assertions.*
import static org.mockito.ArgumentMatchers.*
import static extension org.mockito.Mockito.*
import static extension org.mockito.ArgumentCaptor.*

import static extension io.sarl.tests.api.tools.TestMockito.mock
import static extension org.mockito.Mockito.spy
import static extension org.mockito.Mockito.verify
import static extension io.sarl.sre.services.lifecycle.AgentLife.*
import org.eclipse.xtext.xbase.lib.Procedures.Procedure0

/**
 * @author $Author: sgalland$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 */
@ExtendWith(#[
	typeof(ContextInitExtension),
	typeof(JavaVersionCheckExtension),
	typeof(PropertyRestoreExtension)
])
@DisplayName("unit: InternalEventBusSkill test")
@Tag("unit")
@Tag("janus")
@Tag("sre-unit")
class InternalEventBusSkillTest {

	@Nullable
	var contextId : UUID

	@Nullable
	var agentId : UUID

	@Nullable
	var ^agent : Agent

	@Nullable
	var ^skill : InternalEventBusSkill

	@Nullable
	var eventBus : EventBus

	@Nullable
	var logger : MyLoggingSkill

	@BeforeEach
	def setUp : void {
		this.contextId = UUID::randomUUID
		this.^agentId = UUID::randomUUID
		this.eventBus = typeof(EventBus).mock
		this.logger = new MyLoggingSkill().spy
		this.^agent = new MyAgent(contextId, this.^agentId, this.logger).spy
		this.^skill = new InternalEventBusSkill(this.eventBus)
		this.^skill.class.invokeProc(this.^skill, "setOwner", #[typeof(Agent)], this.^agent)
	}

	@Test
	@DisplayName("getAssociatedEventBusListener not installed skill")
	def getAssociatedEventBusListener_notInstalled {
		var listener = this.^skill.associatedEventBusListener
		listener.assertNull
	}

	@Test
	@DisplayName("getAssociatedEventBusListener installed skill")
	def getAssociatedEventBusListener_installed {
		this.^skill.class.invokeProc(this.^skill, "install", #[])

		var listener1 = this.^skill.associatedEventBusListener
		var listener2 = this.^skill.associatedEventBusListener
		listener1.assertNotNull
		listener2.assertNotNull
		listener1.assertSame(listener2)
	}

	@Test
	@DisplayName("getRegisteredEventBusListeners")
	def getRegisteredEventBusListeners {
		var iterable = new ConcurrentLinkedDeque().spy
		when(this.eventBus.getRegisteredEventListeners(any)).thenReturn(iterable)
		var list = this.^skill.getRegisteredEventBusListeners(null)
		iterable.assertSame(list)
	}

	@Test
	@DisplayName("registerEventBusListener(listener)")
	def registerEventBusListener_notFilter_noCallback {
		var listener1 = typeof(EventListener).mock
		this.^skill.registerEventBusListener(listener1)
		
		var capturedListener = typeof(Object).forClass
		var capturedFilter = typeof(Function1).forClass
		var capturedCallback = typeof(Procedure1).forClass
		this.eventBus.verify.register(capturedListener.capture, capturedFilter.capture, capturedCallback.capture)
		listener1.assertSame(capturedListener.value)
		capturedFilter.value.assertNull
		capturedCallback.value.assertNull
	}

	@Test
	@DisplayName("registerEventBusListener(listener, filter)")
	def registerEventBusListener_filter_noCallback {
		var listener1 = typeof(EventListener).mock
		var filter = typeof(Function1).mock
		this.^skill.registerEventBusListener(listener1, filter)
		
		var capturedListener = typeof(Object).forClass
		var capturedFilter = typeof(Function1).forClass
		var capturedCallback = typeof(Procedure1).forClass
		this.eventBus.verify.register(capturedListener.capture, capturedFilter.capture, capturedCallback.capture)
		listener1.assertSame(capturedListener.value)
		filter.assertSame(capturedFilter.value)
		capturedCallback.value.assertNull
	}

	@Test
	@DisplayName("registerEventBusListener(listener, callback)")
	def registerEventBusListener_notFilter_callback {
		var callback = typeof(Procedure1).mock
		var listener1 = typeof(EventListener).mock
		this.^skill.registerEventBusListener(listener1, null, callback)
		
		var capturedListener = typeof(Object).forClass
		var capturedFilter = typeof(Function1).forClass
		var capturedCallback = typeof(Procedure1).forClass
		this.eventBus.verify.register(capturedListener.capture, capturedFilter.capture, capturedCallback.capture)
		listener1.assertSame(capturedListener.value)
		capturedFilter.value.assertNull
		callback.assertSame(capturedCallback.value)
	}

	@Test
	@DisplayName("registerEventBusListener(listener, filter, callback)")
	def registerEventBusListener_filter_callback {
		var callback = typeof(Procedure1).mock
		var listener1 = typeof(EventListener).mock
		var filter = typeof(Function1).mock
		this.^skill.registerEventBusListener(listener1, filter, callback)
		
		var capturedListener = typeof(Object).forClass
		var capturedFilter = typeof(Function1).forClass
		var capturedCallback = typeof(Procedure1).forClass
		this.eventBus.verify.register(capturedListener.capture, capturedFilter.capture, capturedCallback.capture)
		listener1.assertSame(capturedListener.value)
		filter.assertSame(capturedFilter.value)
		callback.assertSame(capturedCallback.value)
	}

	@Test
	@DisplayName("unregisterEventBusListener")
	def unregisterEventBusListener {
		var listener1 = typeof(EventListener).mock
		this.^skill.unregisterEventBusListener(listener1)
		
		var capturedListener = typeof(Object).forClass
		var capturedCallback = typeof(Procedure1).forClass
		this.eventBus.verify.unregister(capturedListener.capture, capturedCallback.capture)
		listener1.assertSame(capturedListener.value)
		capturedCallback.value.assertNull
	}

	@Test
	@DisplayName("fireEvent(event) not started agent no event handling")
	def fireEvent_agentNotStarted_notEventCaching {
		this.^agent.getLife.state = AgentState::UNSTARTED
		
		this.^skill.eventBuffering = false
		var ^event = typeof(Event).mock
		
		this.^skill.fireEvent(^event)
		
		verifyNoMoreInteractions(this.eventBus)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
	}

	@Test
	@DisplayName("fireEvent(event) initialization no event handling")
	def fireEvent_agentInitialization_notEventCaching {
		this.^agent.getLife.state = AgentState::INITIALIZING
		
		this.^skill.eventBuffering = false
		var ^event = typeof(Event).mock
		
		this.^skill.fireEvent(^event)
		
		var capturedEvent = typeof(Event).forClass
		var capturedLogger = typeof(Logger).forClass
		this.eventBus.verify.asyncDispatch(capturedEvent.capture, capturedLogger.capture)
		assertSame(^event, capturedEvent.value)
		assertSame(this.logger.logger, capturedLogger.value)
		assertFalse(this.^skill.bufferedEvents.iterator.hasNext)
	}

	@Test
	@DisplayName("fireEvent(event) no event handling")
	def fireEvent_agentAlive_notEventCaching {
		this.^agent.getLife.state = AgentState::ALIVE
		
		this.^skill.eventBuffering = false
		var ^event = typeof(Event).mock
		
		this.^skill.fireEvent(^event)
		
		var capturedEvent = typeof(Event).forClass
		var capturedLogger = typeof(Logger).forClass
		this.eventBus.verify.asyncDispatch(capturedEvent.capture, capturedLogger.capture)
		^event.assertSame(capturedEvent.value)
		this.logger.logger.assertSame(capturedLogger.value)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
	}

	@Test
	@DisplayName("fireEvent(event) dying agent no event handling")
	def fireEvent_agentDying_notEventCaching {
		this.^agent.getLife.state = AgentState::DYING
		
		this.^skill.eventBuffering = false
		var ^event = typeof(Event).mock
		
		this.^skill.fireEvent(^event)
		
		verifyNoMoreInteractions(this.eventBus)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
	}

	@Test
	@DisplayName("fireEvent(event) dead agent")
	def fireEvent_agentDead_notEventCaching {
		this.^agent.getLife.state = AgentState::DEAD
		
		this.^skill.eventBuffering = false
		var ^event = typeof(Event).mock
		
		this.^skill.fireEvent(^event)
		
		verifyNoMoreInteractions(this.eventBus)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
	}

	@Test
	@DisplayName("fireEvent(event) dying agent")
	def fireEvent_agentNotStarted_eventCaching {
		this.^agent.getLife.state = AgentState::UNSTARTED
		
		this.^skill.eventBuffering = true
		var ^event = typeof(Event).mock
		
		this.^skill.fireEvent(^event)
		
		verifyNoMoreInteractions(this.eventBus)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
	}

	@Test
	@DisplayName("fireEvent(event) not started agent event handling")
	def fireEvent_agentInitialization_eventCaching {
		this.^agent.getLife.state = AgentState::INITIALIZING
		
		this.^skill.eventBuffering = true
		var ^event = typeof(Event).mock
		
		this.^skill.fireEvent(^event)
		
		verifyNoMoreInteractions(this.eventBus)
		assertContains(this.^skill.bufferedEvents, ^event)
	}

	@Test
	@DisplayName("fireEvent(event) event handling")
	def fireEvent_agentAlive_eventCaching {
		this.^agent.getLife.state = AgentState::ALIVE
		
		this.^skill.eventBuffering = true
		var ^event = typeof(Event).mock
		
		this.^skill.fireEvent(^event)
		
		verifyNoMoreInteractions(this.eventBus)
		this.^skill.bufferedEvents.assertContains(^event)
	}

	@Test
	@DisplayName("fireEvent(event) dying agent event handling")
	def fireEvent_agentDying_eventCaching {
		this.^agent.getLife.state = AgentState::DYING
		
		this.^skill.eventBuffering = true
		var ^event = typeof(Event).mock
		
		this.^skill.fireEvent(^event)
		
		verifyNoMoreInteractions(this.eventBus)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
	}

	@Test
	@DisplayName("fireEvent(event) dead agent event handling")
	def fireEvent_agentDead_eventCaching {
		this.^agent.getLife.state = AgentState::DEAD
		
		this.^skill.eventBuffering = true
		var ^event = typeof(Event).mock
		
		this.^skill.fireEvent(^event)
		
		verifyNoMoreInteractions(this.eventBus)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
	}

	@Test
	@DisplayName("fireEventAndWait(event, no exception catch, no listener) agent not initialized")
	def fireEventAndWait_notExceptionThrowing_agentNotStarted {
		this.^agent.getLife.state = AgentState::UNSTARTED
		
		var ^event = typeof(Event).mock
		
		this.^skill.fireEventAndWait(^event, false)
		
		verifyNoMoreInteractions(this.eventBus)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
	}

	@Test
	@DisplayName("fireEventAndWait(event, no exception catch) agent initializing")
	def fireEventAndWait_notExceptionThrowing_agentInitializing {
		this.^agent.getLife.state = AgentState::INITIALIZING
		
		var ^event = typeof(Event).mock
		
		this.^skill.fireEventAndWait(^event, false)
		
		var capturedEvent = typeof(Event).forClass
		var capturedExceptions = typeof(boolean).forClass
		var capturedLogger = typeof(Logger).forClass
		this.eventBus.verify.immediateDispatch(
			capturedEvent.capture,
			capturedExceptions.capture.booleanValue,
			capturedLogger.capture)
		^event.assertSame(capturedEvent.value)
		capturedExceptions.value.assertFalse
		this.logger.logger.assertSame(capturedLogger.value)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
	}

	@Test
	@DisplayName("fireEventAndWait(event, no exception catch) alive agent")
	def fireEventAndWait_notExceptionThrowing_agentAlive {
		this.^agent.getLife.state = AgentState::ALIVE
		
		var ^event = typeof(Event).mock
		
		this.^skill.fireEventAndWait(^event, false)
		
		var capturedEvent = typeof(Event).forClass
		var capturedExceptions = typeof(boolean).forClass
		var capturedLogger = typeof(Logger).forClass
		this.eventBus.verify.immediateDispatch(
			capturedEvent.capture,
			capturedExceptions.capture.booleanValue,
			capturedLogger.capture)
		^event.assertSame(capturedEvent.value)
		capturedExceptions.value.assertFalse
		this.logger.logger.assertSame(capturedLogger.value)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
	}

	@Test
	@DisplayName("fireEventAndWait(event, no exception catch) dying agent")
	def fireEventAndWait_notExceptionThrowing_agentDying {
		this.^agent.getLife.state = AgentState::DYING
		
		var ^event = typeof(Event).mock
		
		this.^skill.fireEventAndWait(^event, false)
		
		var capturedEvent = typeof(Event).forClass
		var capturedExceptions = typeof(boolean).forClass
		var capturedLogger = typeof(Logger).forClass
		this.eventBus.verify.immediateDispatch(
			capturedEvent.capture,
			capturedExceptions.capture.booleanValue,
			capturedLogger.capture)
		^event.assertSame(capturedEvent.value)
		capturedExceptions.value.assertFalse
		this.logger.logger.assertSame(capturedLogger.value)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
	}

	@Test
	@DisplayName("fireEventAndWait(event, no exception catch) dead agent")
	def fireEventAndWait_notExceptionThrowing_agentDead {
		this.^agent.getLife.state = AgentState::DEAD
		
		var ^event = typeof(Event).mock
		
		this.^skill.fireEventAndWait(^event, false)
		
		verifyNoMoreInteractions(this.eventBus)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
	}

	@Test
	@DisplayName("fireEventAndWait(event, exception catch, no listener) agent not initialized")
	def fireEventAndWait_exceptionThrowing_agentNotStarted {
		this.^agent.getLife.state = AgentState::UNSTARTED
		
		var ^event = typeof(Event).mock
		
		this.^skill.fireEventAndWait(^event, true)
		
		verifyNoMoreInteractions(this.eventBus)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
	}

	@Test
	@DisplayName("fireEventAndWait(event, exception catch) agent initializing")
	def fireEventAndWait_exceptionThrowing_agentInitializing {
		this.^agent.getLife.state = AgentState::INITIALIZING
		
		var ^event = typeof(Event).mock
		
		this.^skill.fireEventAndWait(^event, true)
		
		var capturedEvent = typeof(Event).forClass
		var capturedExceptions = typeof(boolean).forClass
		var capturedLogger = typeof(Logger).forClass
		this.eventBus.verify.immediateDispatch(
			capturedEvent.capture,
			capturedExceptions.capture.booleanValue,
			capturedLogger.capture)
		^event.assertSame(capturedEvent.value)
		capturedExceptions.value.assertTrue
		this.logger.logger.assertSame(capturedLogger.value)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
	}

	@Test
	@DisplayName("fireEventAndWait(event, exception catch) alive agent")
	def fireEventAndWait_exceptionThrowing_agentAlive {
		this.^agent.getLife.state = AgentState::ALIVE
		
		var ^event = typeof(Event).mock
		
		this.^skill.fireEventAndWait(^event, true)
		
		var capturedEvent = typeof(Event).forClass
		var capturedExceptions = typeof(boolean).forClass
		var capturedLogger = typeof(Logger).forClass
		this.eventBus.verify.immediateDispatch(
			capturedEvent.capture,
			capturedExceptions.capture.booleanValue,
			capturedLogger.capture)
		^event.assertSame(capturedEvent.value)
		capturedExceptions.value.assertTrue
		this.logger.logger.assertSame(capturedLogger.value)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
	}

	@Test
	@DisplayName("fireEventAndWait(event, exception catch) dying agent")
	def fireEventAndWait_exceptionThrowing_agentDying {
		this.^agent.getLife.state = AgentState::DYING
		
		var ^event = typeof(Event).mock
		
		this.^skill.fireEventAndWait(^event, true)
		
		var capturedEvent = typeof(Event).forClass
		var capturedExceptions = typeof(boolean).forClass
		var capturedLogger = typeof(Logger).forClass
		this.eventBus.verify.immediateDispatch(
			capturedEvent.capture,
			capturedExceptions.capture.booleanValue,
			capturedLogger.capture)
		^event.assertSame(capturedEvent.value)
		capturedExceptions.value.assertTrue
		this.logger.logger.assertSame(capturedLogger.value)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
	}

	@Test
	@DisplayName("fireEventAndWait(event, exception catch) dead agent")
	def fireEventAndWait_exceptionThrowing_agentDead {
		this.^agent.getLife.state = AgentState::DEAD
		
		var ^event = typeof(Event).mock
		
		this.^skill.fireEventAndWait(^event, true)
		
		verifyNoMoreInteractions(this.eventBus)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
	}
	@Test
	@DisplayName("fireEventAndWait(event, no exception catch, listener) agent not initialized")
	def fireEventAndWait_notExceptionThrowing_listener_agentNotStarted {
		this.^agent.getLife.state = AgentState::UNSTARTED
		
		var ^event = typeof(Event).mock
		var listener = typeof(Object).mock
		
		this.^skill.fireEventAndWait(^event, false, listener)
		
		verifyNoMoreInteractions(this.eventBus)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
	}

	@Test
	@DisplayName("fireEventAndWait(event, no exception catch, listener) agent initializing")
	def fireEventAndWait_notExceptionThrowing_listener_agentInitializing {
		this.^agent.getLife.state = AgentState::INITIALIZING
		
		var ^event = typeof(Event).mock
		var listener = typeof(Object).mock
		
		this.^skill.fireEventAndWait(^event, false, listener)
		
		var capturedListener = typeof(Object).forClass
		var capturedEvent = typeof(Event).forClass
		var capturedExceptions = typeof(boolean).forClass
		var capturedLogger = typeof(Logger).forClass
		this.eventBus.verify.immediateDispatchTo(
			capturedListener.capture,
			capturedEvent.capture,
			capturedExceptions.capture.booleanValue,
			capturedLogger.capture)
		listener.assertSame(capturedListener.value)
		^event.assertSame(capturedEvent.value)
		capturedExceptions.value.assertFalse
		this.logger.logger.assertSame(capturedLogger.value)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
	}

	@Test
	@DisplayName("fireEventAndWait(event, no exception catch, listener) alive agent")
	def fireEventAndWait_notExceptionThrowing_listener_agentAlive {
		this.^agent.getLife.state = AgentState::ALIVE
		
		var ^event = typeof(Event).mock
		var listener = typeof(Object).mock
		
		this.^skill.fireEventAndWait(^event, false, listener)
		
		var capturedListener = typeof(Object).forClass
		var capturedEvent = typeof(Event).forClass
		var capturedExceptions = typeof(boolean).forClass
		var capturedLogger = typeof(Logger).forClass
		this.eventBus.verify.immediateDispatchTo(
			capturedListener.capture,
			capturedEvent.capture,
			capturedExceptions.capture.booleanValue,
			capturedLogger.capture)
		listener.assertSame(capturedListener.value)
		^event.assertSame(capturedEvent.value)
		capturedExceptions.value.assertFalse
		this.logger.logger.assertSame(capturedLogger.value)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
	}

	@Test
	@DisplayName("fireEventAndWait(event, no exception catch, listener) dying agent")
	def fireEventAndWait_notExceptionThrowing_listener_agentDying {
		this.^agent.getLife.state = AgentState::DYING
		
		var ^event = typeof(Event).mock
		var listener = typeof(Object).mock
		
		this.^skill.fireEventAndWait(^event, false, listener)
		
		var capturedListener = typeof(Object).forClass
		var capturedEvent = typeof(Event).forClass
		var capturedExceptions = typeof(boolean).forClass
		var capturedLogger = typeof(Logger).forClass
		this.eventBus.verify.immediateDispatchTo(
			capturedListener.capture,
			capturedEvent.capture,
			capturedExceptions.capture.booleanValue,
			capturedLogger.capture)
		listener.assertSame(capturedListener.value)
		^event.assertSame(capturedEvent.value)
		capturedExceptions.value.assertFalse
		this.logger.logger.assertSame(capturedLogger.value)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
	}

	@Test
	@DisplayName("fireEventAndWait(event, no exception catch, listener) dead agent")
	def fireEventAndWait_notExceptionThrowing_listener_agentDead {
		this.^agent.getLife.state = AgentState::DEAD
		
		var ^event = typeof(Event).mock
		var listener = typeof(Object).mock
		
		this.^skill.fireEventAndWait(^event, false, listener)
		
		verifyNoMoreInteractions(this.eventBus)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
	}

	@Test
	@DisplayName("fireEventAndWait(event, exception catch, listener) agent not initialized")
	def fireEventAndWait_exceptionThrowing_listener_agentNotStarted {
		this.^agent.getLife.state = AgentState::UNSTARTED
		
		var ^event = typeof(Event).mock
		var listener = typeof(Object).mock
		
		this.^skill.fireEventAndWait(^event, true, listener)
		
		verifyNoMoreInteractions(this.eventBus)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
	}

	@Test
	@DisplayName("fireEventAndWait(event, exception catch, listener) agent initializing")
	def fireEventAndWait_exceptionThrowing_listener_agentInitializing {
		this.^agent.getLife.state = AgentState::INITIALIZING
		
		var ^event = typeof(Event).mock
		var listener = typeof(Object).mock
		
		this.^skill.fireEventAndWait(^event, true, listener)

		var capturedListener = typeof(Object).forClass
		var capturedEvent = typeof(Event).forClass
		var capturedExceptions = typeof(boolean).forClass
		var capturedLogger = typeof(Logger).forClass
		this.eventBus.verify.immediateDispatchTo(
			capturedListener.capture,
			capturedEvent.capture,
			capturedExceptions.capture.booleanValue,
			capturedLogger.capture)
		listener.assertSame(capturedListener.value)
		^event.assertSame(capturedEvent.value)
		capturedExceptions.value.assertTrue
		this.logger.logger.assertSame(capturedLogger.value)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
	}

	@Test
	@DisplayName("fireEventAndWait(event, exception catch, listener) alive agent")
	def fireEventAndWait_exceptionThrowing_listener_agentAlive {
		this.^agent.getLife.state = AgentState::ALIVE
		
		var ^event = typeof(Event).mock
		var listener = typeof(Object).mock
		
		this.^skill.fireEventAndWait(^event, true, listener)
		
		var capturedListener = typeof(Object).forClass
		var capturedEvent = typeof(Event).forClass
		var capturedExceptions = typeof(boolean).forClass
		var capturedLogger = typeof(Logger).forClass
		this.eventBus.verify.immediateDispatchTo(
			capturedListener.capture,
			capturedEvent.capture,
			capturedExceptions.capture.booleanValue,
			capturedLogger.capture)
		listener.assertSame(capturedListener.value)
		^event.assertSame(capturedEvent.value)
		capturedExceptions.value.assertTrue
		this.logger.logger.assertSame(capturedLogger.value)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
	}

	@Test
	@DisplayName("fireEventAndWait(event, exception catch, listener) dying agent")
	def fireEventAndWait_exceptionThrowing_listener_agentDying {
		this.^agent.getLife.state = AgentState::DYING
		
		var ^event = typeof(Event).mock
		var listener = typeof(Object).mock
		
		this.^skill.fireEventAndWait(^event, true, listener)
		
		var capturedListener = typeof(Object).forClass
		var capturedEvent = typeof(Event).forClass
		var capturedExceptions = typeof(boolean).forClass
		var capturedLogger = typeof(Logger).forClass
		this.eventBus.verify.immediateDispatchTo(
			capturedListener.capture,
			capturedEvent.capture,
			capturedExceptions.capture.booleanValue,
			capturedLogger.capture)
		listener.assertSame(capturedListener.value)
		^event.assertSame(capturedEvent.value)
		capturedExceptions.value.assertTrue
		this.logger.logger.assertSame(capturedLogger.value)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
	}

	@Test
	@DisplayName("fireEventAndWait(event, exception catch, listener) dead agent")
	def fireEventAndWait_exceptionThrowing_listener_agentDead {
		this.^agent.getLife.state = AgentState::DEAD
		
		var ^event = typeof(Event).mock
		var listener = typeof(Object).mock
		
		this.^skill.fireEventAndWait(^event, true, listener)
		
		verifyNoMoreInteractions(this.eventBus)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
	}


	@Test
	@DisplayName("fireEventAndWaitWithEventGathering(event, no exception catch, no listener) agent not initialized")
	def fireEventAndWaitWithEventGathering_notExceptionThrowing_agentNotStarted {
		this.^agent.getLife.state = AgentState::UNSTARTED
		
		var ^event = typeof(Event).mock
		var handler = typeof(Procedure0).mock
		
		this.^skill.fireEventAndWaitWithEventGathering(^event, false, handler)
		
		verifyNoMoreInteractions(this.eventBus)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
		verifyNoMoreInteractions(handler)
	}

	@Test
	@DisplayName("fireEventAndWaitWithEventGathering(event, no exception catch) agent initializing")
	def fireEventAndWaitWithEventGathering_notExceptionThrowing_agentInitializing {
		this.^agent.getLife.state = AgentState::INITIALIZING
		
		var ^event = typeof(Event).mock
		var handler = typeof(Procedure0).mock
		
		this.^skill.fireEventAndWaitWithEventGathering(^event, false, handler)
		
		var capturedEvent = typeof(Event).forClass
		var capturedExceptions = typeof(boolean).forClass
		var capturedLogger = typeof(Logger).forClass
		this.eventBus.verify.immediateDispatch(
			capturedEvent.capture,
			capturedExceptions.capture.booleanValue,
			capturedLogger.capture)
		^event.assertSame(capturedEvent.value)
		capturedExceptions.value.assertFalse
		this.logger.logger.assertSame(capturedLogger.value)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
		handler.verify(1.times).apply
	}

	@Test
	@DisplayName("fireEventAndWaitWithEventGathering(event, no exception catch) alive agent")
	def fireEventAndWaitWithEventGathering_notExceptionThrowing_agentAlive {
		this.^agent.getLife.state = AgentState::ALIVE
		
		var ^event = typeof(Event).mock
		var handler = typeof(Procedure0).mock
		
		this.^skill.fireEventAndWaitWithEventGathering(^event, false, handler)
		
		var capturedEvent = typeof(Event).forClass
		var capturedExceptions = typeof(boolean).forClass
		var capturedLogger = typeof(Logger).forClass
		this.eventBus.verify.immediateDispatch(
			capturedEvent.capture,
			capturedExceptions.capture.booleanValue,
			capturedLogger.capture)
		^event.assertSame(capturedEvent.value)
		capturedExceptions.value.assertFalse
		this.logger.logger.assertSame(capturedLogger.value)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
		handler.verify(1.times).apply
	}

	@Test
	@DisplayName("fireEventAndWaitWithEventGathering(event, no exception catch) dying agent")
	def fireEventAndWaitWithEventGathering_notExceptionThrowing_agentDying {
		this.^agent.getLife.state = AgentState::DYING
		
		var ^event = typeof(Event).mock
		var handler = typeof(Procedure0).mock
		
		this.^skill.fireEventAndWaitWithEventGathering(^event, false, handler)
		
		var capturedEvent = typeof(Event).forClass
		var capturedExceptions = typeof(boolean).forClass
		var capturedLogger = typeof(Logger).forClass
		this.eventBus.verify.immediateDispatch(
			capturedEvent.capture,
			capturedExceptions.capture.booleanValue,
			capturedLogger.capture)
		^event.assertSame(capturedEvent.value)
		capturedExceptions.value.assertFalse
		this.logger.logger.assertSame(capturedLogger.value)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
		handler.verify(1.times).apply
	}

	@Test
	@DisplayName("fireEventAndWaitWithEventGathering(event, no exception catch) dead agent")
	def fireEventAndWaitWithEventGathering_notExceptionThrowing_agentDead {
		this.^agent.getLife.state = AgentState::DEAD
		
		var ^event = typeof(Event).mock
		var handler = typeof(Procedure0).mock
		
		this.^skill.fireEventAndWaitWithEventGathering(^event, false, handler)
		
		verifyNoMoreInteractions(this.eventBus)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
		verifyNoMoreInteractions(handler)
	}

	@Test
	@DisplayName("fireEventAndWaitWithEventGathering(event, exception catch, no listener) agent not initialized")
	def fireEventAndWaitWithEventGathering_exceptionThrowing_agentNotStarted {
		this.^agent.getLife.state = AgentState::UNSTARTED
		
		var ^event = typeof(Event).mock
		var handler = typeof(Procedure0).mock
		
		this.^skill.fireEventAndWaitWithEventGathering(^event, true, handler)
		
		verifyNoMoreInteractions(this.eventBus)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
		verifyNoMoreInteractions(handler)
	}

	@Test
	@DisplayName("fireEventAndWaitWithEventGathering(event, exception catch) agent initializing")
	def fireEventAndWaitWithEventGathering_exceptionThrowing_agentInitializing {
		this.^agent.getLife.state = AgentState::INITIALIZING
		
		var ^event = typeof(Event).mock
		var handler = typeof(Procedure0).mock
		
		this.^skill.fireEventAndWaitWithEventGathering(^event, true, handler)
		
		var capturedEvent = typeof(Event).forClass
		var capturedExceptions = typeof(boolean).forClass
		var capturedLogger = typeof(Logger).forClass
		this.eventBus.verify.immediateDispatch(
			capturedEvent.capture,
			capturedExceptions.capture.booleanValue,
			capturedLogger.capture)
		^event.assertSame(capturedEvent.value)
		capturedExceptions.value.assertTrue
		this.logger.logger.assertSame(capturedLogger.value)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
		handler.verify(1.times).apply
	}

	@Test
	@DisplayName("fireEventAndWaitWithEventGathering(event, exception catch) alive agent")
	def fireEventAndWaitWithEventGathering_exceptionThrowing_agentAlive {
		this.^agent.getLife.state = AgentState::ALIVE
		
		var ^event = typeof(Event).mock
		var handler = typeof(Procedure0).mock
		
		this.^skill.fireEventAndWaitWithEventGathering(^event, true, handler)
		
		var capturedEvent = typeof(Event).forClass
		var capturedExceptions = typeof(boolean).forClass
		var capturedLogger = typeof(Logger).forClass
		this.eventBus.verify.immediateDispatch(
			capturedEvent.capture,
			capturedExceptions.capture.booleanValue,
			capturedLogger.capture)
		^event.assertSame(capturedEvent.value)
		capturedExceptions.value.assertTrue
		this.logger.logger.assertSame(capturedLogger.value)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
		handler.verify(1.times).apply
	}

	@Test
	@DisplayName("fireEventAndWaitWithEventGathering(event, exception catch) dying agent")
	def fireEventAndWaitWithEventGathering_exceptionThrowing_agentDying {
		this.^agent.getLife.state = AgentState::DYING
		
		var ^event = typeof(Event).mock
		var handler = typeof(Procedure0).mock
		
		this.^skill.fireEventAndWaitWithEventGathering(^event, true, handler)
		
		var capturedEvent = typeof(Event).forClass
		var capturedExceptions = typeof(boolean).forClass
		var capturedLogger = typeof(Logger).forClass
		this.eventBus.verify.immediateDispatch(
			capturedEvent.capture,
			capturedExceptions.capture.booleanValue,
			capturedLogger.capture)
		^event.assertSame(capturedEvent.value)
		capturedExceptions.value.assertTrue
		this.logger.logger.assertSame(capturedLogger.value)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
		handler.verify(1.times).apply
	}

	@Test
	@DisplayName("fireEventAndWaitWithEventGathering(event, exception catch) dead agent")
	def fireEventAndWaitWithEventGathering_exceptionThrowing_agentDead {
		this.^agent.getLife.state = AgentState::DEAD
		
		var ^event = typeof(Event).mock
		var handler = typeof(Procedure0).mock
		
		this.^skill.fireEventAndWaitWithEventGathering(^event, true, handler)
		
		verifyNoMoreInteractions(this.eventBus)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
		verifyNoMoreInteractions(handler)
	}
	@Test
	@DisplayName("fireEventAndWaitWithEventGathering(event, no exception catch, listener) agent not initialized")
	def fireEventAndWaitWithEventGathering_notExceptionThrowing_listener_agentNotStarted {
		this.^agent.getLife.state = AgentState::UNSTARTED
		
		var ^event = typeof(Event).mock
		var listener = typeof(Object).mock
		var handler = typeof(Procedure0).mock
		
		this.^skill.fireEventAndWaitWithEventGathering(^event, false, listener, handler)
		
		verifyNoMoreInteractions(this.eventBus)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
		verifyNoMoreInteractions(handler)
	}

	@Test
	@DisplayName("fireEventAndWaitWithEventGathering(event, no exception catch, listener) agent initializing")
	def fireEventAndWaitWithEventGathering_notExceptionThrowing_listener_agentInitializing {
		this.^agent.getLife.state = AgentState::INITIALIZING
		
		var ^event = typeof(Event).mock
		var listener = typeof(Object).mock
		var handler = typeof(Procedure0).mock
		
		this.^skill.fireEventAndWaitWithEventGathering(^event, false, listener, handler)
		
		var capturedListener = typeof(Object).forClass
		var capturedEvent = typeof(Event).forClass
		var capturedExceptions = typeof(boolean).forClass
		var capturedLogger = typeof(Logger).forClass
		this.eventBus.verify.immediateDispatchTo(
			capturedListener.capture,
			capturedEvent.capture,
			capturedExceptions.capture.booleanValue,
			capturedLogger.capture)
		listener.assertSame(capturedListener.value)
		^event.assertSame(capturedEvent.value)
		capturedExceptions.value.assertFalse
		this.logger.logger.assertSame(capturedLogger.value)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
		handler.verify(1.times).apply
	}

	@Test
	@DisplayName("fireEventAndWaitWithEventGathering(event, no exception catch, listener) alive agent")
	def fireEventAndWaitWithEventGathering_notExceptionThrowing_listener_agentAlive {
		this.^agent.getLife.state = AgentState::ALIVE
		
		var ^event = typeof(Event).mock
		var listener = typeof(Object).mock
		var handler = typeof(Procedure0).mock
		
		this.^skill.fireEventAndWaitWithEventGathering(^event, false, listener, handler)
		
		var capturedListener = typeof(Object).forClass
		var capturedEvent = typeof(Event).forClass
		var capturedExceptions = typeof(boolean).forClass
		var capturedLogger = typeof(Logger).forClass
		this.eventBus.verify.immediateDispatchTo(
			capturedListener.capture,
			capturedEvent.capture,
			capturedExceptions.capture.booleanValue,
			capturedLogger.capture)
		listener.assertSame(capturedListener.value)
		^event.assertSame(capturedEvent.value)
		capturedExceptions.value.assertFalse
		this.logger.logger.assertSame(capturedLogger.value)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
		handler.verify(1.times).apply
	}

	@Test
	@DisplayName("fireEventAndWaitWithEventGathering(event, no exception catch, listener) dying agent")
	def fireEventAndWaitWithEventGathering_notExceptionThrowing_listener_agentDying {
		this.^agent.getLife.state = AgentState::DYING
		
		var ^event = typeof(Event).mock
		var listener = typeof(Object).mock
		var handler = typeof(Procedure0).mock
		
		this.^skill.fireEventAndWaitWithEventGathering(^event, false, listener, handler)
		
		var capturedListener = typeof(Object).forClass
		var capturedEvent = typeof(Event).forClass
		var capturedExceptions = typeof(boolean).forClass
		var capturedLogger = typeof(Logger).forClass
		this.eventBus.verify.immediateDispatchTo(
			capturedListener.capture,
			capturedEvent.capture,
			capturedExceptions.capture.booleanValue,
			capturedLogger.capture)
		listener.assertSame(capturedListener.value)
		^event.assertSame(capturedEvent.value)
		capturedExceptions.value.assertFalse
		this.logger.logger.assertSame(capturedLogger.value)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
		handler.verify(1.times).apply
	}

	@Test
	@DisplayName("fireEventAndWaitWithEventGathering(event, no exception catch, listener) dead agent")
	def fireEventAndWaitWithEventGathering_notExceptionThrowing_listener_agentDead {
		this.^agent.getLife.state = AgentState::DEAD
		
		var ^event = typeof(Event).mock
		var listener = typeof(Object).mock
		var handler = typeof(Procedure0).mock
		
		this.^skill.fireEventAndWaitWithEventGathering(^event, false, listener, handler)
		
		verifyNoMoreInteractions(this.eventBus)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
		verifyNoMoreInteractions(handler)
	}

	@Test
	@DisplayName("fireEventAndWaitWithEventGathering(event, exception catch, listener) agent not initialized")
	def fireEventAndWaitWithEventGathering_exceptionThrowing_listener_agentNotStarted {
		this.^agent.getLife.state = AgentState::UNSTARTED
		
		var ^event = typeof(Event).mock
		var listener = typeof(Object).mock
		var handler = typeof(Procedure0).mock
		
		this.^skill.fireEventAndWaitWithEventGathering(^event, true, listener, handler)
		
		verifyNoMoreInteractions(this.eventBus)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
		verifyNoMoreInteractions(handler)
	}

	@Test
	@DisplayName("fireEventAndWaitWithEventGathering(event, exception catch, listener) agent initializing")
	def fireEventAndWaitWithEventGathering_exceptionThrowing_listener_agentInitializing {
		this.^agent.getLife.state = AgentState::INITIALIZING
		
		var ^event = typeof(Event).mock
		var listener = typeof(Object).mock
		var handler = typeof(Procedure0).mock
		
		this.^skill.fireEventAndWaitWithEventGathering(^event, true, listener, handler)

		var capturedListener = typeof(Object).forClass
		var capturedEvent = typeof(Event).forClass
		var capturedExceptions = typeof(boolean).forClass
		var capturedLogger = typeof(Logger).forClass
		this.eventBus.verify.immediateDispatchTo(
			capturedListener.capture,
			capturedEvent.capture,
			capturedExceptions.capture.booleanValue,
			capturedLogger.capture)
		listener.assertSame(capturedListener.value)
		^event.assertSame(capturedEvent.value)
		capturedExceptions.value.assertTrue
		this.logger.logger.assertSame(capturedLogger.value)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
		handler.verify(1.times).apply
	}

	@Test
	@DisplayName("fireEventAndWaitWithEventGathering(event, exception catch, listener) alive agent")
	def fireEventAndWaitWithEventGathering_exceptionThrowing_listener_agentAlive {
		this.^agent.getLife.state = AgentState::ALIVE
		
		var ^event = typeof(Event).mock
		var listener = typeof(Object).mock
		var handler = typeof(Procedure0).mock
		
		this.^skill.fireEventAndWaitWithEventGathering(^event, true, listener, handler)
		
		var capturedListener = typeof(Object).forClass
		var capturedEvent = typeof(Event).forClass
		var capturedExceptions = typeof(boolean).forClass
		var capturedLogger = typeof(Logger).forClass
		this.eventBus.verify.immediateDispatchTo(
			capturedListener.capture,
			capturedEvent.capture,
			capturedExceptions.capture.booleanValue,
			capturedLogger.capture)
		listener.assertSame(capturedListener.value)
		^event.assertSame(capturedEvent.value)
		capturedExceptions.value.assertTrue
		this.logger.logger.assertSame(capturedLogger.value)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
		handler.verify(1.times).apply
	}

	@Test
	@DisplayName("fireEventAndWaitWithEventGathering(event, exception catch, listener) dying agent")
	def fireEventAndWaitWithEventGathering_exceptionThrowing_listener_agentDying {
		this.^agent.getLife.state = AgentState::DYING
		
		var ^event = typeof(Event).mock
		var listener = typeof(Object).mock
		var handler = typeof(Procedure0).mock
		
		this.^skill.fireEventAndWaitWithEventGathering(^event, true, listener, handler)
		
		var capturedListener = typeof(Object).forClass
		var capturedEvent = typeof(Event).forClass
		var capturedExceptions = typeof(boolean).forClass
		var capturedLogger = typeof(Logger).forClass
		this.eventBus.verify.immediateDispatchTo(
			capturedListener.capture,
			capturedEvent.capture,
			capturedExceptions.capture.booleanValue,
			capturedLogger.capture)
		listener.assertSame(capturedListener.value)
		^event.assertSame(capturedEvent.value)
		capturedExceptions.value.assertTrue
		this.logger.logger.assertSame(capturedLogger.value)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
		handler.verify(1.times).apply
	}

	@Test
	@DisplayName("fireEventAndWaitWithEventGathering(event, exception catch, listener) dead agent")
	def fireEventAndWaitWithEventGathering_exceptionThrowing_listener_agentDead {
		this.^agent.getLife.state = AgentState::DEAD
		
		var ^event = typeof(Event).mock
		var listener = typeof(Object).mock
		var handler = typeof(Procedure0).mock
		
		this.^skill.fireEventAndWaitWithEventGathering(^event, true, listener, handler)
		
		verifyNoMoreInteractions(this.eventBus)
		this.^skill.bufferedEvents.iterator.hasNext.assertFalse
		verifyNoMoreInteractions(handler)
	}

}
