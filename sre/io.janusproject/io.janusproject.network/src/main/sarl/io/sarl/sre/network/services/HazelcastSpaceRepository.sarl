package io.sarl.sre.network.services

import com.google.inject.Injector
import com.hazelcast.collection.ISet
import com.hazelcast.core.EntryEvent
import com.hazelcast.core.EntryListener
import com.hazelcast.core.HazelcastInstance
import com.hazelcast.map.IMap
import com.hazelcast.map.MapEvent
import io.sarl.api.naming.name.SpaceName
import io.sarl.lang.core.Space
import io.sarl.lang.core.SpaceID
import io.sarl.lang.core.SpaceSpecification
import io.sarl.sre.boot.configs.SreConfig
import io.sarl.sre.internal.SmartListenerCollection
import io.sarl.sre.services.context.ContextService
import io.sarl.sre.services.context.LocalSpaceRepository
import io.sarl.sre.services.context.SpaceRepository.SpaceDescription
import io.sarl.sre.services.executor.ExecutorService
import io.sarl.sre.services.logging.LoggingService
import io.sarl.sre.spaces.SreSpaceSpecificationFactory
import java.util.UUID
import java.util.concurrent.ConcurrentHashMap
import java.util.logging.Level
import java.util.logging.Logger
import javax.inject.Inject

class HazelcastSpaceRepository extends LocalSpaceRepository {

	/** 
	 * Local Hazelcast instance
	 */
	var hazelcastInstance : HazelcastInstance;

	/** 
	 * The set of the id of all spaces stored in this repository This set must be
	 * distributed and synchronized all over the network.
	 */
	var spaceIDs : IMap<SpaceID, Object[]>

	/** 
	 * ContextService used to check if the enclosing context exists when creating a new local space according to netwrok space creation event
	 */
	var contextService : ContextService

	/** 
	 * ID of the listener defined on spaceIDs map
	 */
	var spaceIDsListernerID : UUID

	/** 
	 * Set of existing distributed topics (at least one per space)
	 */
	var availableTopicsName : ISet<String>

	/** 
	 * SRE Kernel logger
	 */
	var kernelLogger : Logger;

	public static val HAZELCAST_SPACE_ID_MAP_NAME = "io.sarl.network.distributedSpaceIDMapName"

	@Inject
	new(injector : Injector, executor : ExecutorService, config : SreConfig,
		specificationFactory : SreSpaceSpecificationFactory,
		internalStructure : ConcurrentHashMap<UUID, SpaceDescription>, listenerCollection : SmartListenerCollection<?>,
		icontextService : ContextService, iHazelcastInstance : HazelcastInstance, logger : LoggingService) {
		super(injector, executor, config, specificationFactory, listenerCollection)
		contextService = icontextService
		hazelcastInstance = iHazelcastInstance
		kernelLogger = logger.kernelLogger
		kernelLogger.log(Level::INFO, "Creating HazelcastSpaceRepository")
		availableTopicsName = this.hazelcastInstance.getSet(
			HazelcastEventTransportService.HAZELCAST_SARL_TOPICS_NAME_SET);
		spaceIDs = this.hazelcastInstance.getMap(HAZELCAST_SPACE_ID_MAP_NAME);

		var spaceIDsListerner = new EntryListener<SpaceID, Object[]>() {

			override entryAdded(^event : EntryEvent<SpaceID, Object[]>) {
				assert spaceIDs.containsKey(^event.getKey());
				ensureLocalSpaceDefinition(^event.getKey(), ^event.value);
			}

			override entryEvicted(^event : EntryEvent<SpaceID, Object[]>) {
				assert !spaceIDs.containsKey(^event.getKey());
				removeLocalSpaceDefinition(^event.getKey(), false);
			}

			override entryRemoved(^event : EntryEvent<SpaceID, Object[]>) {
				assert !spaceIDs.containsKey(^event.getKey());
				removeLocalSpaceDefinition(^event.getKey(), false);
			}

			override entryUpdated(^event : EntryEvent<SpaceID, Object[]>) {
				//
			}

			override mapCleared(^event : MapEvent) {
				removeLocalSpaceDefinitions();
			}

			override mapEvicted(^event : MapEvent) {
			}

			override entryExpired(^event : EntryEvent<SpaceID, Object[]>) {
			}

		}
		spaceIDsListernerID = spaceIDs.addEntryListener(spaceIDsListerner, true)
		kernelLogger.log(Level::INFO, "End of Creating HazelcastSpaceRepository")

	}

	protected override createSpaceFirstInstance(spec : Class<? extends SpaceSpecification<S>>, spaceID : SpaceID,
		creationParams : Object[]) : S with S extends Space {

		// checking that the enclosing context of this new space already exists locally before creating the space
		var localContext = contextService.getContext(spaceID.contextID)
		if (localContext === null) {
			kernelLogger.log(Level::SEVERE,
				"ERROR: Creating a space but the corresponding enclosing context did not exist locally")
		}
		this.spaceIDs.putIfAbsent(spaceID, creationParams);
		// FIXME Extract topic name creation in a dedicated function
		var topicName : String = HazelcastEventTransportService.getTopicNameFromSpaceID(spaceID)
		kernelLogger.log(Level::INFO,
			"HazelcastSpaceRepository: New space created "+spaceID+", adding a new topic named " + topicName)
		this.availableTopicsName.add(topicName)

		return super.createSpaceFirstInstance(spec, spaceID, creationParams);

	}

	/** 
	 * Add the existing, but not yet known, spaces into this repository.
	 * 
	 * @param id identifier of the space
	 * @param initializationParameters parameters for initialization.
	 */
	protected def ensureLocalSpaceDefinition(id : SpaceID, initializationParameters : Object[]) with S extends Space {
		if (!existsSpace(id.ID)) {
			var spec : Class<? extends SpaceSpecification<S>> = id.
				spaceSpecification as Class<? extends SpaceSpecification<S>>
			super.createSpace(id, spec, initializationParameters)
		}
	}

	protected def removeLocalSpaceDefinition(id : SpaceID, isLocalDestruction : boolean) {
		// FIXME Extract topic name creation in a dedicated function
		var topicName : String = HazelcastEventTransportService.HAZELCAST_SARL_TOPICS_ROOTWILCARD + SpaceName.SCHEME +
			"." + id.contextID + "." + id.ID
		kernelLogger.log(Level::INFO, "HazelcastSpaceRepository: Space removed, removing the topic named " + topicName)
		this.availableTopicsName.remove(topicName)
		super.removeSpaceIfEmpty(id.ID)
	}

	/** 
	 * Remove all the local/remote spaces.
	 * 
	 */
	protected def removeLocalSpaceDefinitions() {
		// FIXME update this.availableTopicsName to remove all empty spaces that are effectively empty all over the network
		super.removeAllSpacesIfEmpty
	}

	protected override safeDestroy {
		super.safeDestroy
		// TODO check if it is really necessary to clean this distributed map of spaces, because it will impact other kernels staying active on the network
		this.spaceIDs.clear
		this.spaceIDs.removeEntryListener(this.spaceIDsListernerID);
	}

}
