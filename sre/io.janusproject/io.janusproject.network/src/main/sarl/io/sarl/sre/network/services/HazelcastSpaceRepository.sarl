package io.sarl.sre.network.services

import com.google.inject.Injector
import com.hazelcast.core.EntryEvent
import com.hazelcast.core.EntryListener
import com.hazelcast.core.HazelcastInstance
import com.hazelcast.map.IMap
import com.hazelcast.map.MapEvent
import io.sarl.lang.core.Space
import io.sarl.lang.core.SpaceID
import io.sarl.lang.core.SpaceSpecification
import io.sarl.sre.boot.configs.SreConfig
import io.sarl.sre.internal.SmartListenerCollection
import io.sarl.sre.services.context.ContextService
import io.sarl.sre.services.context.LocalSpaceRepository
import io.sarl.sre.services.context.SpaceRepository.SpaceDescription
import io.sarl.sre.services.executor.ExecutorService
import io.sarl.sre.services.logging.LoggingService
import io.sarl.sre.spaces.SreSpaceSpecificationFactory
import java.util.UUID
import java.util.concurrent.ConcurrentHashMap
import java.util.logging.Level
import java.util.logging.Logger
import javax.inject.Inject
import javax.inject.Named

class HazelcastSpaceRepository extends LocalSpaceRepository {

		/** 
		 * Local Hazelcast instance
		 */
	var hazelcastInstance : HazelcastInstance;

	/** 
	 * The set of the id of all spaces stored in this repository This set must be
	 * distributed and synchronized all over the network.
	 */
	var spaceIDs : IMap<SpaceID, Object[]>

	/** 
	 * ContextService used to check if the enclosing context exists when creating a new local space according to netwrok space creation event
	 */
	var contextService : ContextService

	/** 
	 * ID of the listener defined on spaceIDs map
	 */
	var spaceIDsListernerID : UUID

	/** 
	 * SRE Kernel logger
	 */
	var kernelLogger : Logger;

	public static val HAZELCAST_SPACE_ID_MAP_NAME = "io.sarl.network.distributedSpaceIDMapName"

	@Inject
	new(injector : Injector, executor : ExecutorService, config : SreConfig,
		specificationFactory : SreSpaceSpecificationFactory,
		internalStructure : ConcurrentHashMap<UUID, SpaceDescription>, listenerCollection : SmartListenerCollection<?>,
		icontextService : ContextService, iHazelcastInstance : HazelcastInstance,logger : LoggingService) {
		super(injector, executor, config, specificationFactory, listenerCollection)
		contextService = icontextService
		hazelcastInstance = iHazelcastInstance
		kernelLogger = logger.kernelLogger
		spaceIDs = this.hazelcastInstance.getMap(HAZELCAST_SPACE_ID_MAP_NAME);

		var spaceIDsListerner = new EntryListener<SpaceID, Object[]>() {

			override entryAdded(^event : EntryEvent<SpaceID, Object[]>) {
				assert spaceIDs.containsKey(^event.getKey());
				ensureLocalSpaceDefinition(^event.getKey(), ^event.value);
			}

			override entryEvicted(^event : EntryEvent<SpaceID, Object[]>) {
				assert !spaceIDs.containsKey(^event.getKey());
				removeLocalSpaceDefinition(^event.getKey(), false);
			}

			override entryRemoved(^event : EntryEvent<SpaceID, Object[]>) {
				assert !spaceIDs.containsKey(^event.getKey());
				removeLocalSpaceDefinition(^event.getKey(), false);
			}

			override entryUpdated(^event : EntryEvent<SpaceID, Object[]>) {
				//
			}

			override mapCleared(^event : MapEvent) {
				removeLocalSpaceDefinitions();
			}

			override mapEvicted(^event : MapEvent) {
			}

			override entryExpired(^event : EntryEvent<SpaceID, Object[]>) {
			}

		}
		spaceIDsListernerID = spaceIDs.addEntryListener(spaceIDsListerner, true)

	}


	protected override createSpaceFirstInstance(spec : Class<? extends SpaceSpecification<S>>, spaceID : SpaceID,
		creationParams : Object[]) : S with S extends Space {

		// checking that the enclosing context of this new space already exists locally before creating the space
		var localContext = contextService.getContext(spaceID.contextID)
		if (localContext === null) {
			kernelLogger.log(Level::SEVERE,
				"ERROR: Creating a space but the corresponding enclosing context did not exist locally")
		}
		this.spaceIDs.putIfAbsent(spaceID, creationParams);

		return super.createSpaceFirstInstance(spec, spaceID, creationParams);

	}

	/** 
	 * Add the existing, but not yet known, spaces into this repository.
	 * 
	 * @param id identifier of the space
	 * @param initializationParameters parameters for initialization.
	 */
	protected def ensureLocalSpaceDefinition(id : SpaceID, initializationParameters : Object[]) with S extends Space {
		if (existsSpace(id.ID)) {
			var spec : Class<? extends SpaceSpecification<S>> = id.
				spaceSpecification as Class<? extends SpaceSpecification<S>>
			super.createSpace(id, spec, initializationParameters)
		}
	}

	protected def removeLocalSpaceDefinition(id : SpaceID, isLocalDestruction : boolean) {
		super.removeSpaceIfEmpty(id.ID)
	}

	/** 
	 * Remove all the local/remote spaces.
	 * 
	 */
	protected def removeLocalSpaceDefinitions() {
		super.removeAllSpacesIfEmpty
	}

	protected override safeDestroy {
		super.safeDestroy
		// TODO check if it is really necessary to clean this distributed map of spaces, because it will impact other kernels staying active on the network
		this.spaceIDs.clear
		this.spaceIDs.removeEntryListener(this.spaceIDsListernerID);
	}

}
