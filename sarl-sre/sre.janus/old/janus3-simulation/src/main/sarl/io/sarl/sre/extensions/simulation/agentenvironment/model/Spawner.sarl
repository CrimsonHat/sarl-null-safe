/* 
 * $Id$
 * This file is a part of the Arakhne Foundation Classes, http://www.arakhne.org/afc
 * 
 * Copyright (c) 2000-2012 Stephane GALLAND.
 * Copyright (c) 2005-10, Multiagent Team, Laboratoire Systemes et Transports,
 * Universite de Technologie de Belfort-Montbeliard.
 * Copyright (c) 2013-2020 The original authors, and other authors.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.sarl.sre.extensions.simulation.agentenvironment.model

import io.sarl.lang.core.Agent
import java.util.UUID
import java.util.concurrent.TimeUnit
import org.arakhne.afc.math.stochastic.StochasticLaw
import org.eclipse.xtend.lib.annotations.Accessors
import java.util.Map
import io.sarl.sre.services.time.TimeService

/**
 * Spawner of agents and their associated bodies.
 *
 * @param <EM> the type of the environment model.
 * @param <B> the type of the agent bodies.
 * @author $Author: sgalland$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 */
abstract class Spawner<EM extends AgentEnvironmentModel<B, ?>, B extends AgentBody> {

	@Accessors(PUBLIC_GETTER)
	var id : UUID

	@Accessors(PUBLIC_GETTER)
	var law : StochasticLaw

	@Accessors(PUBLIC_GETTER)
	var agentType : Class<? extends Agent>

	@Accessors(PUBLIC_GETTER)
	var bodyType : Class<? extends B>

	@Accessors(PUBLIC_GETTER)
	var budget : int

	@Accessors(PUBLIC_GETTER)
	val bodyParameters : Map<String, Object>

	@Accessors(PUBLIC_GETTER)
	var agentParameters : Object[]

	var memorizedAmount = 0.0
	
	/** Constructor.
	 *
	 * @param id is the optional identifier of the spawner. If it not provided one is choosen randomly.
	 * @param law is the stochastic law used for generation.
	 * @param budget is the maximum number of generation to be done by this spawner.
	 * @param agentType is the type of agents that are created by this spawner.
	 * @param agentParameters are the initialization arguments to pass to the created agents.
	 * @param bodyType is the type of bodys that are created by this spawner.
	 * @param bodyParameters are the creation arguments to pass to the created bodies.
	 */
	new (id : UUID = null, law : StochasticLaw, budget : int, agentType : Class<? extends Agent>,
		agentParameters : Object[], bodyType : Class<? extends B>, bodyParameters : Map<String, Object>) {
		assert law !== null
		this.id = if (id === null) UUID::randomUUID else id
		this.law = law
		this.agentType = agentType
		this.bodyType = bodyType
		this.budget = budget
		this.bodyParameters = bodyParameters
		this.agentParameters = agentParameters
	}

	/** Determine the number of entities to be generated/spawned according to the current time
	 * state.
	 *
	 * @param timeManager is the service that provides time information
	 */
	def spawnableAt(timeManager : TimeService) : int {
		var b = getBudget
		if (b > 0) {
			var amountPerHour = this.law.generateRandomValue
			if (amountPerHour > 0.0) {
				var stepDuration = timeManager.dt.convertFromTo(TimeUnit::SECONDS, TimeUnit::HOURS)
				val newAmount = stepDuration * amountPerHour
				this.memorizedAmount += newAmount
				if (this.memorizedAmount >= 1.0) {
					var a = this.memorizedAmount as int
					if (a <= 0) {
						return 0
					}
					if (a >= b) {
						return b
					}
					return a
				}
			}
		}
		return 0
	}

	def spawned(count : int) : int {
		this.budget -= count
		if (this.budget < 0) {
			this.budget = 0
		}
		this.memorizedAmount -= count
		if (this.memorizedAmount < 0.0) {
			this.memorizedAmount = 0.0
		}
		return this.budget
	}

	abstract def createBody(timeManager : TimeManager, environmentModel : EM) : B

	abstract def canCreateBodyPhysically(timeManager : TimeManager, environmentModel : EM) : boolean

}
