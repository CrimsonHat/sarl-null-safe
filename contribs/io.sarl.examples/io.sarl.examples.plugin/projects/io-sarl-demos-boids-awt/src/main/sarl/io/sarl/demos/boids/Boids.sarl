/* 
 * $Id$
 * 
 * SARL is an general-purpose agent programming language.
 * More details on http://www.sarl.io
 * 
 * Copyright (C) 2014-@RELEASE_YEAR@ the original authors or authors.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.sarl.demos.boids

import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.core.Schedules
import java.util.Collection
import java.util.UUID
import org.arakhne.afc.math.geometry.d2.d.Vector2d

/**
 * @author Nicolas Gaud
 */
agent Boid {

	uses Logging, DefaultContextInteractions, Schedules

	// ID of the environmental agent
	var environment : UUID

	var EnvtWidth : int

	var EnvtHeight : int

	var position : Vector2d

	var speed : Vector2d

	var group : Population

	val traverseWalls = Settings::traverseWalls

	val distObstacles : double = Settings::obstacleDistance

	val obstaclesForceFactor : double = Settings::obstaclesForceFactor

	on Initialize {
		// 6 Boids init parameters : UUID envt, int EnvtGrilleHauteur, int EnvtGrilleLargeur, Population p, Vector2d initialPosition, Vector2d initialVitesse, String boidName
		if (occurrence.parameters.size > 6) {
			if (occurrence.parameters.get(0) instanceof UUID) {
				environment = occurrence.parameters.get(0) as UUID
			}

			if (occurrence.parameters.get(1) instanceof Integer) {
				EnvtHeight = occurrence.parameters.get(1) as Integer
			}

			if (occurrence.parameters.get(2) instanceof Integer) {
				EnvtWidth = occurrence.parameters.get(2) as Integer
			}

			if (occurrence.parameters.get(3) instanceof Population) {
				group = occurrence.parameters.get(3) as Population
			}

			if (occurrence.parameters.get(4) instanceof Vector2d) {
				position = occurrence.parameters.get(4) as Vector2d
			}
			if (occurrence.parameters.get(5) instanceof Vector2d) {
				speed = occurrence.parameters.get(5) as Vector2d
				speed.length = 0.25
				speed += new Vector2d(0, 0.75)
				speed.scale(group.maxSpeed)
			}
			if (occurrence.parameters.get(6) instanceof String) {
				loggingName = occurrence.parameters.get(6) as String
			}

		}

		"Boids activated".info
	}

	on Perception {
		var boids = occurrence.perceivedAgentBody
		var myBody = boids.get(ID)
		if ((myBody !== null) && (myBody.owner == this.ID)) {
			// Update les donnÃ©es internes de l'agent en fonction de l'environnement
			this.position = myBody.position
			this.speed = myBody.vitesse		
		}
		in(Settings::pause) [
			emit(new Action => [influence = think(boids.values)])[it.UUID == this.environment]
		]
	}

	/************** Boid Methods ****************************
	 */

	def think(perception : Collection<PerceivedBoidBody>) : Vector2d {
		if (perception !== null) {
			var force : Vector2d
			var influence = new Vector2d

			influence.set(0,0)

			if (group.separationOn) {
				force = perception.separation
				force.scale(group.separationForce)
				influence += force
			}

			if (group.cohesionOn) {
				force = perception.cohesion
				force.scale(group.cohesionForce)
				influence += force
			}

			if (group.alignmentOn) {
				force = perception.alignment
				force.scale(group.alignmentForce)
				influence += force
			}

			if (group.repulsionOn) {
				force = perception.repulsion
				force.scale(group.repulsionForce)
				influence += force
			}

			if (!traverseWalls) {
				force = obstacles
				force.scale(obstaclesForceFactor)
				influence += force
			}

			if (influence.length > group.maxForce) {
				influence.length = group.maxForce
			}

			influence.scale(1 / group.mass)

			return influence
		}
	}

	def isNear(otherBoid : PerceivedBoidBody, distance : double) : boolean {
		var tmp = position - otherBoid.position
		return tmp.length <= distance
	}

	def isVisible(otherBoid : PerceivedBoidBody, distance : double) : boolean {
		var tmp = otherBoid.position - position

		if (tmp.length > distance)
			return false

		var tmp2 = speed.clone
		tmp2.normalize

		if (tmp2 * tmp < group.visibleAngleCos)
			return false

		return true
	}

	/** Compute the separation force.
	 */
	def separation(otherBoids : Collection<PerceivedBoidBody>) : Vector2d {
		var force = new Vector2d
		var len = 0.0

		for (otherBoid : otherBoids) {
			if ((otherBoid !== null) && (otherBoid.owner != this.ID) && (otherBoid.group == group) &&
				(isVisible(otherBoid, group.distSeparation))) {
				var tmp = position - otherBoid.position
				len = tmp.length
				// force : 1/r
				tmp.scale(1.0 / (len**2))
				force += tmp
			}
		}
		return force
	}

	/** Compute the cohesion force.
	 */
	def cohesion(otherBoids : Collection<PerceivedBoidBody>) : Vector2d {
		var nbTot = 0
		var force = new Vector2d

		for (otherBoid : otherBoids) {
			if ((otherBoid !== null) && (otherBoid.owner != this.ID) && (otherBoid.group == group) &&
				(isVisible(otherBoid, group.distCohesion))) {
				nbTot++
				force += otherBoid.position
			}
		}

		// computation of the barycentre.
		if (nbTot > 0) {
			force.scale(1.0 / nbTot)
			force -= position
		}
		return force
	}

	/** Compute the alignment force.
	 */
	def alignment(otherBoids : Collection<PerceivedBoidBody>) : Vector2d {
		var nbTot = 0
		var tmp = new Vector2d
		var force = new Vector2d

		for (otherBoid : otherBoids) {
			if ((otherBoid !== null) && (otherBoid.owner != this.ID) && (otherBoid.group == group) &&
				(isVisible(otherBoid, group.distAlignment))) {
				nbTot++
				tmp.set(otherBoid.vitesse)
				tmp.scale(1.0 / tmp.length)
				force += tmp
			}
		}

		if (nbTot > 0) {
			force.scale(1.0 / nbTot)
		}
		return force
	}

	/** 
	 * Compute the repulsion force.
	 */
	def repulsion(otherBoids : Collection<PerceivedBoidBody>) : Vector2d {
		var force = new Vector2d
		var len = 0.0

		for (otherBoid : otherBoids) {
			if ((otherBoid !== null) && (otherBoid.owner != this.ID) && (otherBoid.group != group) &&
				isVisible(otherBoid, group.distRepulsion)) {
				var tmp = position - otherBoid.position
				len = tmp.length
				tmp.scale(1 / (len**2))
				force += tmp
			}
		}
		return force
	}

	def obstacles : Vector2d {
		var tmp = new Vector2d
		var force = new Vector2d

		if (((EnvtWidth - position.x) < distObstacles) && speed.x > 0) {
			tmp.set(-speed.x / (EnvtWidth - position.x), 0);
			force += tmp
		}
		if ((position.x < -EnvtWidth + distObstacles) && speed.x < 0) {
			tmp.set(-speed.x / (EnvtWidth + position.x), 0);
			force += tmp
		}

		if ((position.y > EnvtHeight - distObstacles) && speed.y > 0) {
			tmp.set(0, -speed.y / (EnvtHeight - position.y));
			force += tmp
		}

		if ((position.y < -EnvtHeight + distObstacles) && speed.y < 0) {
			tmp.set(0, -speed.y / (EnvtHeight + position.y));
			force += tmp
		}

		force.scale(group.mass)
		return force
	}

}
